{"mappings":"IGyyCI,E,S,E,C,E,O,G,E,U,C,E,O,C,C,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,A,C,E,E,Q,A,E,Q,S,C,C,C,E,O,c,C,E,O,C,W,C,I,I,E,I,A,G,E,E,W,C,E,a,C,C,GFvyCJ,IAgBA,EAhBI,EAAU,IAAI,IAgBlB,EAfA,SAAkB,CAAO,CAAE,CAAQ,EACjC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAG,EAAG,GAAK,EAC5C,EAAQ,GAAG,CAAC,CAAQ,CAAC,EAAE,CAAE,CACvB,QAAS,EACT,KAAM,CAAQ,CAAC,EAAI,EAAE,AACvB,EAEJ,C,GCVA,AAAA,EAAA,SAAA,QAAA,CAA8C,IAAA,IAAoB,GAAA,YAAA,GAAA,EAAI,QAAQ,GAAG,KAAK,KAAK,CAAC,qM,I,E,C,EEA5F,EAAiB,IAAA,IAAoB,mCAAA,YAAA,GAAA,EAAoC,QAAQ,G,I,E,C,ECAjF,EAAiB,IAAA,IAAoB,uCAAA,YAAA,GAAA,EAAwC,QAAQ,G,I,E,C,ECArF,EAAiB,IAAA,IAAoB,gDAAA,YAAA,GAAA,EAAiD,QAAQ,GHI9F,MAAM,EAAS,SAAS,cAAc,CAAC,eACjC,EAAM,EAAO,UAAU,CAAC,KAG9B,CAAA,EAAO,KAAK,CAFU,IAGtB,EAAO,MAAM,CAFU,IAOvB,IAAI,EAAQ,EACR,EAAY,EACZ,EAAW,EAEX,EAAsB,EACtB,EAAW,CAAA,EACX,EAAgB,CACpB,CAAA,EAAI,IAAI,CAAG,kBAGX,OAAO,SAAS,CAAG,CACjB,IAAI,UAAW,CAAE,OAAO,CAAU,EAClC,IAAI,SAAS,MAAO,CAClB,CAAA,EAAW,KAAX,EAaF,AADiB,SAAS,gBAAgB,CAAC,SAClC,OAAO,CAAC,AAAA,IACV,EAAM,MAAM,EACf,EAAM,KAAK,EAEf,IAKA,EAAM,IAAI,GAA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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-e21a87dba7fd0f45.js","src/game.js","node_modules/@parcel/runtime-js/lib/runtime-9c4e89e565bbb33e.js","node_modules/@parcel/runtime-js/lib/runtime-a35bca7ea2d30b1a.js","node_modules/@parcel/runtime-js/lib/runtime-d8b2de5ecdb90a97.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"27Lyk\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $18c11f3350a906ea$export$6503ec6e8aabbaf, (v) => $18c11f3350a906ea$export$6503ec6e8aabbaf = v);\nvar $18c11f3350a906ea$export$6503ec6e8aabbaf;\nvar $18c11f3350a906ea$export$f7ad0328861e2f03;\n\"use strict\";\nvar $18c11f3350a906ea$var$mapping = new Map();\nfunction $18c11f3350a906ea$var$register(baseUrl, manifest) {\n    for(var i = 0; i < manifest.length - 1; i += 2)$18c11f3350a906ea$var$mapping.set(manifest[i], {\n        baseUrl: baseUrl,\n        path: manifest[i + 1]\n    });\n}\nfunction $18c11f3350a906ea$var$resolve(id) {\n    var resolved = $18c11f3350a906ea$var$mapping.get(id);\n    if (resolved == null) throw new Error('Could not resolve bundle with id ' + id);\n    return new URL(resolved.path, resolved.baseUrl).toString();\n}\n$18c11f3350a906ea$export$6503ec6e8aabbaf = $18c11f3350a906ea$var$register;\n$18c11f3350a906ea$export$f7ad0328861e2f03 = $18c11f3350a906ea$var$resolve;\n\n});\n\nvar $c5e252a31290a44f$exports = {};\n\n(parcelRequire(\"27Lyk\")).register(new URL(\"\", import.meta.url).toString(), JSON.parse(\"[\\\"4Zi2e\\\",\\\"index.461ec126.js\\\",\\\"id7cg\\\",\\\"bg.51ef01c9.png\\\",\\\"2eqI5\\\",\\\"patrol.9736c357.png\\\",\\\"lkgDT\\\",\\\"tanker-sprite-2.95dcef17.png\\\"]\"));\n\nvar $ec1cf3883ace6448$exports = {};\n$ec1cf3883ace6448$exports = new URL(\"bg.51ef01c9.png\", import.meta.url).toString();\n\n\nvar $2ae5a384eaded8e6$exports = {};\n$2ae5a384eaded8e6$exports = new URL(\"patrol.9736c357.png\", import.meta.url).toString();\n\n\nvar $6f487f3626976b0d$exports = {};\n$6f487f3626976b0d$exports = new URL(\"tanker-sprite-2.95dcef17.png\", import.meta.url).toString();\n\n\nconst $4ee2b06a9c1953f0$var$canvas = document.getElementById('game-canvas');\nconst $4ee2b06a9c1953f0$var$ctx = $4ee2b06a9c1953f0$var$canvas.getContext('2d');\nconst $4ee2b06a9c1953f0$var$DEFAULT_WIDTH = 800;\nconst $4ee2b06a9c1953f0$var$DEFAULT_HEIGHT = 500;\n$4ee2b06a9c1953f0$var$canvas.width = $4ee2b06a9c1953f0$var$DEFAULT_WIDTH;\n$4ee2b06a9c1953f0$var$canvas.height = $4ee2b06a9c1953f0$var$DEFAULT_HEIGHT;\nconst $4ee2b06a9c1953f0$var$TANKER_IMAGE_WIDTH = 344, $4ee2b06a9c1953f0$var$TANKER_IMAGE_HEIGHT = 52;\nlet $4ee2b06a9c1953f0$var$score = 0;\nlet $4ee2b06a9c1953f0$var$gameFrame = 0;\nlet $4ee2b06a9c1953f0$var$warnings = 0;\nconst $4ee2b06a9c1953f0$var$gameSpeed = 1;\nlet $4ee2b06a9c1953f0$var$previousChainLength = 0;\nlet $4ee2b06a9c1953f0$var$isPaused = false;\nlet $4ee2b06a9c1953f0$var$detectionRisk = 0; // 0-100 scale for patrol detection risk\n$4ee2b06a9c1953f0$var$ctx.font = '24px sans-serif';\n// Expose game state to window for cross-module access\nwindow.gameState = {\n    get isPaused () {\n        return $4ee2b06a9c1953f0$var$isPaused;\n    },\n    set isPaused (value){\n        $4ee2b06a9c1953f0$var$isPaused = value;\n        // Pause/resume all audio when game is paused\n        if ($4ee2b06a9c1953f0$var$isPaused) $4ee2b06a9c1953f0$var$pauseAllAudio();\n        else $4ee2b06a9c1953f0$var$resumeAllAudio();\n    }\n};\n// Audio control functions\nfunction $4ee2b06a9c1953f0$var$pauseAllAudio() {\n    const allAudio = document.querySelectorAll('audio');\n    allAudio.forEach((audio)=>{\n        if (!audio.paused) audio.pause();\n    });\n}\nfunction $4ee2b06a9c1953f0$var$resumeAllAudio() {\n    // Only resume looping background audio, not one-shot sounds\n    $4ee2b06a9c1953f0$var$music.play().catch(()=>{});\n    $4ee2b06a9c1953f0$var$wind1.play().catch(()=>{});\n    $4ee2b06a9c1953f0$var$waves.play().catch(()=>{});\n    $4ee2b06a9c1953f0$var$ship.play().catch(()=>{});\n}\n// Audio elements map\nconst $4ee2b06a9c1953f0$var$audioElements = {\n    metal1: document.getElementById('metal1'),\n    metal2: document.getElementById('metal2'),\n    metal3: document.getElementById('metal3'),\n    metal4: document.getElementById('metal4'),\n    metal5: document.getElementById('metal5')\n};\n// All other audio elements\nconst $4ee2b06a9c1953f0$var$music = document.getElementById('music');\nconst $4ee2b06a9c1953f0$var$wind1 = document.getElementById('wind1');\nconst $4ee2b06a9c1953f0$var$waves = document.getElementById('waves');\nconst $4ee2b06a9c1953f0$var$ship = document.getElementById('ship');\nconst $4ee2b06a9c1953f0$var$winch1 = document.getElementById('winch1');\nconst $4ee2b06a9c1953f0$var$winch5 = document.getElementById('winch5');\nconst $4ee2b06a9c1953f0$var$winch8 = document.getElementById('winch8');\nconst $4ee2b06a9c1953f0$var$scrape7 = document.getElementById('scrape7');\nconst $4ee2b06a9c1953f0$var$alarm1 = document.getElementById('alarm1');\nconst $4ee2b06a9c1953f0$var$splash = document.getElementById('splash');\n// Get metal sounds from audioElements for convenience\nconst $4ee2b06a9c1953f0$var$metal1 = $4ee2b06a9c1953f0$var$audioElements.metal1;\nconst $4ee2b06a9c1953f0$var$metal2 = $4ee2b06a9c1953f0$var$audioElements.metal2;\nconst $4ee2b06a9c1953f0$var$metal3 = $4ee2b06a9c1953f0$var$audioElements.metal3;\nconst $4ee2b06a9c1953f0$var$metal4 = $4ee2b06a9c1953f0$var$audioElements.metal4;\nconst $4ee2b06a9c1953f0$var$metal5 = $4ee2b06a9c1953f0$var$audioElements.metal5;\nconst $4ee2b06a9c1953f0$var$targetPosition = {\n    x: $4ee2b06a9c1953f0$var$canvas.width / 2 - $4ee2b06a9c1953f0$var$TANKER_IMAGE_WIDTH / 2,\n    y: $4ee2b06a9c1953f0$var$canvas.height / 1.5\n};\ndocument.addEventListener('keydown', function(e) {\n    e.preventDefault();\n    // Reel anchor up - slower (harder to pull up)\n    if (e.key === 'ArrowUp') {\n        $4ee2b06a9c1953f0$var$tanker.chainLength = Math.max(0, $4ee2b06a9c1953f0$var$tanker.chainLength - 5);\n        $4ee2b06a9c1953f0$var$winch8.volume = 0.25;\n        $4ee2b06a9c1953f0$var$winch8.play().catch(()=>{});\n    }\n    // Lower anchor - faster (easier to drop) - only if anchors remain\n    if (e.key === 'ArrowDown' && $4ee2b06a9c1953f0$var$hud.remainingAnchors > 0) {\n        $4ee2b06a9c1953f0$var$tanker.chainLength = Math.min($4ee2b06a9c1953f0$var$tanker.chainLength + 20, $4ee2b06a9c1953f0$var$tanker.chainLengthMax);\n        $4ee2b06a9c1953f0$var$winch1.volume = 0.25;\n        $4ee2b06a9c1953f0$var$winch1.play().catch(()=>{});\n    }\n    // Back\n    if (e.key === 'ArrowLeft') $4ee2b06a9c1953f0$var$targetPosition.x -= 5;\n    // Forward\n    if (e.key === 'ArrowRight') $4ee2b06a9c1953f0$var$targetPosition.x += 20;\n});\n// Player\nconst $4ee2b06a9c1953f0$var$tankerImage = new Image();\n$4ee2b06a9c1953f0$var$tankerImage.src = (0, (/*@__PURE__*/$parcel$interopDefault($6f487f3626976b0d$exports)));\nclass $4ee2b06a9c1953f0$var$Tanker {\n    constructor(){\n        this.x = $4ee2b06a9c1953f0$var$targetPosition.x;\n        this.y = $4ee2b06a9c1953f0$var$targetPosition.y;\n        this.frameX = 0;\n        this.frameY = 0;\n        this.frame = 0;\n        this.spriteWidth = $4ee2b06a9c1953f0$var$TANKER_IMAGE_WIDTH;\n        this.spriteHeight = $4ee2b06a9c1953f0$var$TANKER_IMAGE_HEIGHT;\n        this.chainLength = 0;\n        this.chainLengthMax = 2000; // Increased to allow 4x depth (max depth ~470, so 4x ~1880)\n    }\n    update() {\n        const dx = this.x - $4ee2b06a9c1953f0$var$targetPosition.x;\n        const dy = this.y - $4ee2b06a9c1953f0$var$targetPosition.y;\n        // Calculate speed reduction based on anchor dragging\n        let speedMultiplier = 1.0; // Normal speed\n        // EXTREME slowdown when dragging through a cable (5 seconds after cable cut)\n        if ($4ee2b06a9c1953f0$var$hud.lastCableCut && $4ee2b06a9c1953f0$var$gameFrame - $4ee2b06a9c1953f0$var$hud.lastCableTime < 300) {\n            // Nearly stopped: 2-8% speed depending on cable difficulty\n            const cableDifficulty = $4ee2b06a9c1953f0$var$hud.lastCableCut.difficulty || 1;\n            speedMultiplier = 0.02 + cableDifficulty * 0.012; // Harder cables = slightly more resistance\n        } else if (this.chainLength > 0) {\n            // Anchor is deployed - boat slows down\n            if (this.chainLength >= $4ee2b06a9c1953f0$var$hud.depth) {\n                // Anchor is touching/dragging on seabed - dramatic slowdown\n                const dragAmount = this.chainLength - $4ee2b06a9c1953f0$var$hud.depth;\n                const maxDrag = $4ee2b06a9c1953f0$var$hud.depth * 4; // Max optimal range\n                const dragRatio = Math.min(dragAmount / maxDrag, 1.0);\n                // Speed reduces dramatically: 30% speed when just touching, down to 5% at max drag\n                speedMultiplier = 0.3 - dragRatio * 0.25;\n            } else {\n                // Anchor deployed but not touching seabed - moderate slowdown based on chain length\n                const deployRatio = Math.min(this.chainLength / $4ee2b06a9c1953f0$var$hud.depth, 1.0);\n                // Speed reduces from 100% to 50% as anchor gets closer to seabed\n                speedMultiplier = 1.0 - deployRatio * 0.5;\n            }\n        }\n        // Apply speed with drag resistance\n        const effectiveSpeed = 100 / speedMultiplier;\n        if ($4ee2b06a9c1953f0$var$targetPosition.x != this.x) this.x -= dx / effectiveSpeed;\n        if ($4ee2b06a9c1953f0$var$targetPosition.y != this.y) this.y -= dy / effectiveSpeed;\n        if ($4ee2b06a9c1953f0$var$gameFrame % 5 == 0) {\n            // Dynamic animation based on chain length relative to optimal range\n            const minOptimal = $4ee2b06a9c1953f0$var$hud.depth * 2;\n            const maxOptimal = $4ee2b06a9c1953f0$var$hud.depth * 4;\n            const inSweetSpot = this.chainLength >= minOptimal && this.chainLength <= maxOptimal;\n            if (this.chainLength < 10) {\n                // No anchor deployed\n                this.frameY = 0;\n                this.frameX = 0;\n            } else if (this.chainLength < minOptimal * 0.5) {\n                // Light deployment (< half of min optimal)\n                this.frameY = 1;\n                this.frameX = 0;\n            } else if (!inSweetSpot) {\n                // Moderate deployment (approaching or past sweet spot)\n                if (Math.random() <= 0.01) $4ee2b06a9c1953f0$var$winch5.play().catch(()=>{});\n                if (Math.random() <= 0.96) {\n                    this.frameY = 0;\n                    this.frameX = 1;\n                } else {\n                    this.frameY = 0;\n                    this.frameX = 2;\n                }\n            } else // In sweet spot (2x-4x depth)\n            if (Math.random() <= 0.8) {\n                this.frameY = 0;\n                this.frameX = 2;\n            } else {\n                this.frameY = 1;\n                this.frameX = 2;\n            }\n            // Scraping and creaking sounds when anchor is dragging on seabed\n            if (this.chainLength >= $4ee2b06a9c1953f0$var$hud.depth) {\n                const dragAmount = this.chainLength - $4ee2b06a9c1953f0$var$hud.depth;\n                const maxDrag = $4ee2b06a9c1953f0$var$hud.depth * 4;\n                const dragRatio = Math.min(dragAmount / maxDrag, 1.0);\n                // More frequent sounds the more you drag: 5% base, up to 25% at max drag\n                const soundChance = 0.05 + dragRatio * 0.20;\n                if (Math.random() <= soundChance) {\n                    // Random metal creaking sounds\n                    const metalSounds = [\n                        $4ee2b06a9c1953f0$var$metal1,\n                        $4ee2b06a9c1953f0$var$metal2,\n                        $4ee2b06a9c1953f0$var$metal3,\n                        $4ee2b06a9c1953f0$var$metal4,\n                        $4ee2b06a9c1953f0$var$metal5\n                    ];\n                    const randomMetal = metalSounds[Math.floor(Math.random() * metalSounds.length)];\n                    randomMetal.volume = 0.08 + dragRatio * 0.12; // Louder with more drag\n                    randomMetal.play().catch(()=>{});\n                    this.frameY = 1;\n                    this.frameX = 2;\n                }\n                // Scraping sound at optimal dragging depth\n                if ($4ee2b06a9c1953f0$var$hud.isAnchorDown && Math.random() <= 0.08) {\n                    $4ee2b06a9c1953f0$var$scrape7.volume = 0.12 + dragRatio * 0.08;\n                    $4ee2b06a9c1953f0$var$scrape7.play().catch(()=>{});\n                }\n            }\n        }\n    }\n    draw() {\n        $4ee2b06a9c1953f0$var$ctx.drawImage($4ee2b06a9c1953f0$var$tankerImage, this.frameX * this.spriteWidth, this.frameY * this.spriteHeight, this.spriteWidth, this.spriteHeight, this.x, this.y, this.spriteWidth, this.spriteHeight);\n    }\n}\nconst $4ee2b06a9c1953f0$var$tanker = new $4ee2b06a9c1953f0$var$Tanker();\nconst $4ee2b06a9c1953f0$var$background = new Image();\n$4ee2b06a9c1953f0$var$background.src = (0, (/*@__PURE__*/$parcel$interopDefault($ec1cf3883ace6448$exports)));\nconst $4ee2b06a9c1953f0$var$BG = {\n    x1: 0,\n    x2: $4ee2b06a9c1953f0$var$canvas.width,\n    y: 0,\n    width: $4ee2b06a9c1953f0$var$canvas.width,\n    height: $4ee2b06a9c1953f0$var$canvas.height\n};\nfunction $4ee2b06a9c1953f0$var$createBackground() {\n    $4ee2b06a9c1953f0$var$BG.x1 -= $4ee2b06a9c1953f0$var$gameSpeed;\n    $4ee2b06a9c1953f0$var$BG.x2 -= $4ee2b06a9c1953f0$var$gameSpeed;\n    if ($4ee2b06a9c1953f0$var$BG.x1 < -$4ee2b06a9c1953f0$var$BG.width) $4ee2b06a9c1953f0$var$BG.x1 = $4ee2b06a9c1953f0$var$BG.x2 + $4ee2b06a9c1953f0$var$BG.width; // Add new background when current moves out\n    if ($4ee2b06a9c1953f0$var$BG.x2 < -$4ee2b06a9c1953f0$var$BG.width) $4ee2b06a9c1953f0$var$BG.x2 = $4ee2b06a9c1953f0$var$BG.x1 + $4ee2b06a9c1953f0$var$BG.width; // Add new background when current moves out\n    // Draw the background images on both sides\n    $4ee2b06a9c1953f0$var$ctx.drawImage($4ee2b06a9c1953f0$var$background, $4ee2b06a9c1953f0$var$BG.x1, $4ee2b06a9c1953f0$var$BG.y, $4ee2b06a9c1953f0$var$BG.width, $4ee2b06a9c1953f0$var$BG.height);\n    $4ee2b06a9c1953f0$var$ctx.drawImage($4ee2b06a9c1953f0$var$background, $4ee2b06a9c1953f0$var$BG.x2, $4ee2b06a9c1953f0$var$BG.y, $4ee2b06a9c1953f0$var$BG.width, $4ee2b06a9c1953f0$var$BG.height);\n}\n// Patrols\nconst $4ee2b06a9c1953f0$var$patrolsArray = [];\nconst $4ee2b06a9c1953f0$var$patrolImage = new Image();\n$4ee2b06a9c1953f0$var$patrolImage.src = (0, (/*@__PURE__*/$parcel$interopDefault($2ae5a384eaded8e6$exports)));\nclass $4ee2b06a9c1953f0$var$Patrol {\n    constructor(){\n        // Spawn patrols off-screen to the right with some randomness\n        this.x = $4ee2b06a9c1953f0$var$canvas.width + Math.random() * $4ee2b06a9c1953f0$var$canvas.width * 0.5;\n        // Y position varies slightly for visual interest\n        this.y = $4ee2b06a9c1953f0$var$canvas.height / 1.4 + (Math.random() * 40 - 20);\n        this.frameX = 0;\n        this.frameY = 0;\n        this.distance;\n        this.frame = 0;\n        this.spriteWidth = 52;\n        this.spriteHeight = 52;\n        this.sound = Math.random() <= 0.5 ? 'alarm1' : 'alarm2';\n        this.speed = 0.3 + Math.random() * 0.4; // Initial speed 0.3-0.7\n    }\n    update() {\n        this.age++;\n        this.x -= this.speed; // Move upward\n    }\n    setSpeed(speed) {\n        this.speed = speed;\n    }\n    draw() {\n        $4ee2b06a9c1953f0$var$ctx.drawImage($4ee2b06a9c1953f0$var$patrolImage, this.frameX * this.spriteWidth, this.frameY * this.spriteHeight, this.spriteWidth, this.spriteHeight, this.x, this.y, this.spriteWidth, this.spriteHeight);\n    }\n}\nfunction $4ee2b06a9c1953f0$var$randomBetween(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n// Particle system for water splash effects\nclass $4ee2b06a9c1953f0$var$Particle {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n        this.vx = (Math.random() - 0.5) * 2; // Small horizontal velocity\n        this.vy = Math.random() * -2 - 0.5; // Small upward velocity\n        this.gravity = 0.15;\n        this.life = 1.0;\n        this.decay = 0.05; // Faster fade for brief splash\n        this.size = Math.random() * 1.5 + 1; // Very small particles (1-2.5px)\n        this.color = `rgba(255, 255, 255, ${this.life})`;\n    }\n    update() {\n        this.x += this.vx;\n        this.y += this.vy;\n        this.vy += this.gravity;\n        this.life -= this.decay;\n        const alpha = this.life * 0.6;\n        this.color = `rgba(220, 240, 255, ${alpha})`;\n    }\n    draw() {\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = this.color;\n        $4ee2b06a9c1953f0$var$ctx.beginPath();\n        $4ee2b06a9c1953f0$var$ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n        $4ee2b06a9c1953f0$var$ctx.fill();\n    }\n    isDead() {\n        return this.life <= 0;\n    }\n}\nconst $4ee2b06a9c1953f0$var$particlesArray = [];\nfunction $4ee2b06a9c1953f0$var$createSplashParticles(x, y, count = 15) {\n    for(let i = 0; i < count; i++)$4ee2b06a9c1953f0$var$particlesArray.push(new $4ee2b06a9c1953f0$var$Particle(x, y));\n}\nfunction $4ee2b06a9c1953f0$var$updateParticles() {\n    for(let i = $4ee2b06a9c1953f0$var$particlesArray.length - 1; i >= 0; i--){\n        $4ee2b06a9c1953f0$var$particlesArray[i].update();\n        $4ee2b06a9c1953f0$var$particlesArray[i].draw();\n        if ($4ee2b06a9c1953f0$var$particlesArray[i].isDead()) $4ee2b06a9c1953f0$var$particlesArray.splice(i, 1);\n    }\n}\nfunction $4ee2b06a9c1953f0$var$createPatrols() {\n    // Don't spawn patrols for the first 90 seconds (5400 frames) to give player time to learn\n    const minimumStartDelay = 5400; // 90 seconds at 60 FPS\n    // Spawn patrols very rarely: every 200-600 seconds / 3.3-10 minutes (at 60 FPS)\n    if ($4ee2b06a9c1953f0$var$gameFrame > minimumStartDelay && $4ee2b06a9c1953f0$var$gameFrame % $4ee2b06a9c1953f0$var$randomBetween(12000, 36000) === 0) $4ee2b06a9c1953f0$var$patrolsArray.push(new $4ee2b06a9c1953f0$var$Patrol());\n    // Calculate detection risk ONLY if anchor is down\n    $4ee2b06a9c1953f0$var$detectionRisk = 0;\n    for(let i = 0; i < $4ee2b06a9c1953f0$var$patrolsArray.length; i++){\n        // alarm1.play()\n        $4ee2b06a9c1953f0$var$patrolsArray[i].update();\n        $4ee2b06a9c1953f0$var$patrolsArray[i].draw();\n        if ($4ee2b06a9c1953f0$var$patrolsArray[i].x > 200 && $4ee2b06a9c1953f0$var$patrolsArray[i].x < 700) {\n            $4ee2b06a9c1953f0$var$patrolsArray[i].setSpeed(0.5);\n            // Only calculate risk if anchor is down\n            if ($4ee2b06a9c1953f0$var$tanker.chainLength > 0) {\n                const distance = Math.abs($4ee2b06a9c1953f0$var$patrolsArray[i].x - ($4ee2b06a9c1953f0$var$tanker.x + $4ee2b06a9c1953f0$var$TANKER_IMAGE_WIDTH / 2));\n                if (distance < 400) {\n                    // Exponential decay: risk drops off quickly with distance\n                    // At distance 0: 100%, at 200: ~14%, at 400: ~2%\n                    const proximityRisk = 100 * Math.exp(-distance / 100);\n                    $4ee2b06a9c1953f0$var$detectionRisk = Math.max($4ee2b06a9c1953f0$var$detectionRisk, proximityRisk);\n                }\n            }\n            if ($4ee2b06a9c1953f0$var$patrolsArray[i].x > 400 && $4ee2b06a9c1953f0$var$patrolsArray[i].x < 550) {\n                if ($4ee2b06a9c1953f0$var$tanker.chainLength != 0) {\n                    // Accumulate warnings faster when in critical detection zone\n                    $4ee2b06a9c1953f0$var$warnings += 2;\n                    $4ee2b06a9c1953f0$var$detectionRisk = Math.max($4ee2b06a9c1953f0$var$detectionRisk, 85); // Very high risk in detection zone with anchor down\n                }\n                $4ee2b06a9c1953f0$var$patrolsArray[i].setSpeed(0.3);\n            }\n        } else $4ee2b06a9c1953f0$var$patrolsArray[i].setSpeed(1);\n        if ($4ee2b06a9c1953f0$var$patrolsArray[i].x < -52) {\n            $4ee2b06a9c1953f0$var$score++;\n            $4ee2b06a9c1953f0$var$patrolsArray.splice(i, 1);\n            i--;\n        }\n    }\n}\nfunction $4ee2b06a9c1953f0$var$createTanker() {\n    $4ee2b06a9c1953f0$var$tanker.update();\n    $4ee2b06a9c1953f0$var$tanker.draw();\n    // Anchor position at the front right of the ship\n    const anchorX = $4ee2b06a9c1953f0$var$tanker.x + $4ee2b06a9c1953f0$var$TANKER_IMAGE_WIDTH * 0.9; // Front right edge\n    const anchorY = $4ee2b06a9c1953f0$var$tanker.y + $4ee2b06a9c1953f0$var$TANKER_IMAGE_HEIGHT; // At ship's bottom edge\n    // Play warning alarm when entering critical depth (5x)\n    // Actual anchor loss is handled by Hud.update()\n    const anchorLossThreshold = $4ee2b06a9c1953f0$var$hud.depth * 5;\n    if ($4ee2b06a9c1953f0$var$tanker.chainLength >= anchorLossThreshold) {\n        if ($4ee2b06a9c1953f0$var$previousChainLength < anchorLossThreshold) {\n            // First time crossing threshold - play alarm\n            $4ee2b06a9c1953f0$var$alarm1.volume = 0.3;\n            $4ee2b06a9c1953f0$var$alarm1.play().catch(()=>{});\n        }\n    }\n    // Check if anchor was just lost (from Hud.update())\n    if ($4ee2b06a9c1953f0$var$hud.anchorLost && $4ee2b06a9c1953f0$var$gameFrame === $4ee2b06a9c1953f0$var$hud.anchorLostTime) {\n        $4ee2b06a9c1953f0$var$createSplashParticles(anchorX, anchorY, 25); // Big splash\n        $4ee2b06a9c1953f0$var$splash.volume = 0.3;\n        $4ee2b06a9c1953f0$var$splash.play().catch(()=>{});\n        // Add detection risk penalty\n        $4ee2b06a9c1953f0$var$detectionRisk = Math.min(100, $4ee2b06a9c1953f0$var$detectionRisk + 20);\n    }\n    // Trigger small splash when anchor first deploys (0 -> 10+)\n    if ($4ee2b06a9c1953f0$var$tanker.chainLength >= 10 && $4ee2b06a9c1953f0$var$previousChainLength === 0) {\n        $4ee2b06a9c1953f0$var$createSplashParticles(anchorX, anchorY, 10);\n        $4ee2b06a9c1953f0$var$splash.volume = 0.1;\n        $4ee2b06a9c1953f0$var$splash.play().catch(()=>{});\n    }\n    // Trigger splash when anchor is raised (10+ -> 0)\n    // More particles if raising from deep deployment\n    if ($4ee2b06a9c1953f0$var$tanker.chainLength === 0 && $4ee2b06a9c1953f0$var$previousChainLength >= 10) {\n        const particleCount = Math.min(15, 8 + Math.floor($4ee2b06a9c1953f0$var$previousChainLength / 100));\n        $4ee2b06a9c1953f0$var$createSplashParticles(anchorX, anchorY, particleCount);\n        $4ee2b06a9c1953f0$var$splash.volume = Math.min(0.2, 0.1 + $4ee2b06a9c1953f0$var$previousChainLength / 5000);\n        $4ee2b06a9c1953f0$var$splash.play().catch(()=>{});\n    }\n    $4ee2b06a9c1953f0$var$previousChainLength = $4ee2b06a9c1953f0$var$tanker.chainLength;\n}\n// Cable type definitions with gameplay properties\nconst $4ee2b06a9c1953f0$var$CABLE_TYPES = {\n    SCRAP: {\n        name: 'Old Scrap Cable',\n        color: '#8b8b7a',\n        difficulty: 1,\n        reward: 1,\n        risk: 1,\n        rarity: 0.35,\n        riskIncrease: 0\n    },\n    RESEARCH: {\n        name: 'Research Sensor Cable',\n        color: '#5a8ca8',\n        difficulty: 1,\n        reward: 2,\n        risk: 1,\n        rarity: 0.30,\n        riskIncrease: 5\n    },\n    FIBER: {\n        name: 'Fiber Data Cable',\n        color: '#a8f088',\n        difficulty: 3,\n        reward: 4,\n        risk: 3,\n        rarity: 0.25,\n        riskIncrease: 15\n    },\n    MILITARY: {\n        name: 'Military Surveillance Line',\n        color: '#ff6b7a',\n        difficulty: 5,\n        reward: 4,\n        risk: 5,\n        rarity: 0.06,\n        riskIncrease: 40\n    },\n    HVDC: {\n        name: 'HVDC Power Cable',\n        color: '#ffa940',\n        difficulty: 5,\n        reward: 5,\n        risk: 5,\n        rarity: 0.04,\n        riskIncrease: 35\n    }\n};\nclass $4ee2b06a9c1953f0$var$Hud {\n    constructor(){\n        this.depth = Math.floor(this.generateRealisticDepth());\n        this.isAnchorDown = false;\n        this.draggedInMeters = 0;\n        this.cablesCut = 0; // Total cables severed\n        this.cablesByType = {\n            SCRAP: 0,\n            RESEARCH: 0,\n            FIBER: 0,\n            MILITARY: 0,\n            HVDC: 0\n        };\n        this.lastCableCut = null; // Store last cable cut info\n        this.lastCableTime = 0; // When last cable was cut\n        this.depthHistory = []; // Track past depths for graph\n        this.futureDepths = []; // Track upcoming depths for graph\n        this.maxHistoryLength = 30; // Keep 30 past readings (50% of graph)\n        this.maxFutureLength = 30; // Keep 30 future readings (50% of graph)\n        this.depthTrend = 0; // Tracks if we're in shallow basin or approaching deep depression\n        this.optimalCenterDepth = 3.0; // Center of optimal range (varies between 2.5-3.5)\n        this.optimalVariance = 0.3; // 0.3 around center\n        this.remainingAnchors = 2; // Ship has 2 anchors total\n        this.anchorLost = false; // Track if anchor was just lost\n        this.anchorLostTime = 0; // When anchor was lost\n        this.anchorLossReason = ''; // Track reason: 'cable' or 'depth'\n        this.anchorDangerStartTime = 0; // Track when anchor entered danger zone\n        this.missionSuccess = false; // Track if mission succeeded\n        this.successTime = 0; // When mission was completed\n        // Pre-generate initial future depths\n        this.generateFutureDepths();\n    }\n    // Select random cable type based on rarity\n    selectCableType() {\n        const roll = Math.random();\n        let cumulative = 0;\n        for (const [key, cable] of Object.entries($4ee2b06a9c1953f0$var$CABLE_TYPES)){\n            cumulative += cable.rarity;\n            if (roll < cumulative) return {\n                type: key,\n                ...cable\n            };\n        }\n        return {\n            type: 'SCRAP',\n            ...$4ee2b06a9c1953f0$var$CABLE_TYPES.SCRAP\n        };\n    }\n    // Generate future depth predictions\n    generateFutureDepths() {\n        this.futureDepths = [];\n        let lastDepth = this.depth;\n        for(let i = 0; i < this.maxFutureLength; i++){\n            // Use same gradual depth generation with smoothing\n            if (Math.random() < 0.90) {\n                // Very smooth transition (90% of the time)\n                const targetDepth = this.generateRealisticDepth();\n                lastDepth = Math.floor(lastDepth * 0.92 + targetDepth * 0.08);\n            } else if (Math.random() < 0.97) {\n                // Moderate change (7% of the time)\n                const targetDepth = this.generateRealisticDepth();\n                lastDepth = Math.floor(lastDepth * 0.75 + targetDepth * 0.25);\n            } else // Sudden change (3% of the time)\n            lastDepth = Math.floor(this.generateRealisticDepth());\n            this.futureDepths.push(lastDepth);\n        }\n    }\n    // Update optimal depth with variance (simulates cable depth variations)\n    updateOptimalDepth() {\n        // Slowly vary the optimal depth between 2.5-3.5x\n        this.optimalCenterDepth += (Math.random() - 0.5) * 0.05; // Small random walk\n        // Clamp between 2.5 and 3.5\n        this.optimalCenterDepth = Math.max(2.5, Math.min(3.5, this.optimalCenterDepth));\n    }\n    // Generate realistic Baltic Sea depth with varied terrain\n    generateRealisticDepth() {\n        const rand = Math.random();\n        // 70% shallow basin (20-80m) - typical Baltic Sea\n        if (rand < 0.70) return $4ee2b06a9c1953f0$var$randomBetween(20, 80);\n        else if (rand < 0.90) return $4ee2b06a9c1953f0$var$randomBetween(80, 150);\n        else if (rand < 0.98) return $4ee2b06a9c1953f0$var$randomBetween(150, 300);\n        else return $4ee2b06a9c1953f0$var$randomBetween(300, 459);\n    }\n    update() {\n        // Less frequent depth changes: every 600 frames (10 seconds at 60 FPS)\n        if ($4ee2b06a9c1953f0$var$gameFrame % 600 == 0) {\n            // Move current depth to history\n            this.depthHistory.push(this.depth);\n            if (this.depthHistory.length > this.maxHistoryLength) this.depthHistory.shift(); // Remove oldest\n            // Move first future depth to current\n            if (this.futureDepths.length > 0) this.depth = this.futureDepths.shift();\n            // Generate one new future depth to maintain the array\n            if (this.futureDepths.length > 0) {\n                const lastFuture = this.futureDepths[this.futureDepths.length - 1];\n                let newFutureDepth;\n                // Much more gradual depth transitions\n                if (Math.random() < 0.90) {\n                    // Very smooth transition (90% of the time)\n                    const targetDepth = this.generateRealisticDepth();\n                    newFutureDepth = Math.floor(lastFuture * 0.92 + targetDepth * 0.08);\n                } else if (Math.random() < 0.97) {\n                    // Moderate change (7% of the time)\n                    const targetDepth = this.generateRealisticDepth();\n                    newFutureDepth = Math.floor(lastFuture * 0.75 + targetDepth * 0.25);\n                } else // Sudden change (3% of the time)\n                newFutureDepth = Math.floor(this.generateRealisticDepth());\n                this.futureDepths.push(newFutureDepth);\n            }\n            // Update optimal cable depth variance\n            this.updateOptimalDepth();\n        }\n        if ($4ee2b06a9c1953f0$var$gameFrame % 30 == 0) {\n            // Dynamic optimal range: center variance (e.g., 3.0 0.3 = 2.7-3.3x depth)\n            const minOptimal = this.depth * (this.optimalCenterDepth - this.optimalVariance);\n            const maxOptimal = this.depth * (this.optimalCenterDepth + this.optimalVariance);\n            const perfectOptimal = this.depth * this.optimalCenterDepth; // Best depth (e.g., 3.0x)\n            // Check if anchor is deployed deep enough to drag (min optimal or deeper)\n            const anchorLossThreshold = this.depth * 5; // Critical depth\n            const dangerZoneEnd = maxOptimal * 1.5;\n            const inDangerZone = $4ee2b06a9c1953f0$var$tanker.chainLength > maxOptimal && $4ee2b06a9c1953f0$var$tanker.chainLength <= dangerZoneEnd;\n            const inCriticalZone = $4ee2b06a9c1953f0$var$tanker.chainLength >= anchorLossThreshold;\n            // Allow cable cutting at any depth >= minOptimal (including danger zone)\n            this.isAnchorDown = $4ee2b06a9c1953f0$var$tanker.chainLength >= minOptimal && !inCriticalZone;\n            if (this.isAnchorDown) {\n                this.draggedInMeters += 10;\n                // Cable encounter probability based on how close to perfect depth\n                const depthDiff = Math.abs($4ee2b06a9c1953f0$var$tanker.chainLength - perfectOptimal);\n                const maxDiff = perfectOptimal * this.optimalVariance;\n                // Probability calculation\n                let encounterChance;\n                if ($4ee2b06a9c1953f0$var$tanker.chainLength <= maxOptimal) // GREEN ZONE: 1.0 at perfect depth, decreases to 0.3 at edges\n                encounterChance = 1.0 - depthDiff / maxDiff * 0.7;\n                else if (inDangerZone) {\n                    // DANGER ZONE (too deep): reduced efficiency (0.15 - 0.05)\n                    const dangerDepth = ($4ee2b06a9c1953f0$var$tanker.chainLength - maxOptimal) / (dangerZoneEnd - maxOptimal);\n                    encounterChance = 0.15 - dangerDepth * 0.10;\n                } else encounterChance = 0.05; // Very low outside zones\n                // Extremely rare: 0.15% base chance per check\n                if (Math.random() < encounterChance * 0.0015) {\n                    // Select cable type\n                    const cable = this.selectCableType();\n                    // Difficulty check: harder cables need better depth accuracy\n                    const difficultyThreshold = 1.0 - cable.difficulty * 0.15; // Difficulty 5 = 0.25 threshold\n                    const passedCheck = encounterChance >= difficultyThreshold;\n                    if (passedCheck) {\n                        this.cablesCut++;\n                        this.cablesByType[cable.type]++;\n                        this.lastCableCut = cable;\n                        this.lastCableTime = $4ee2b06a9c1953f0$var$gameFrame;\n                        // WIN CONDITION: Successfully cutting MILITARY or HVDC cable wins the mission!\n                        if (cable.type === 'MILITARY' || cable.type === 'HVDC') {\n                            this.missionSuccess = true;\n                            this.successTime = $4ee2b06a9c1953f0$var$gameFrame;\n                        }\n                        // Increase detection risk based on cable type\n                        $4ee2b06a9c1953f0$var$detectionRisk = Math.min(100, $4ee2b06a9c1953f0$var$detectionRisk + cable.riskIncrease);\n                        // Risk of losing anchor when cutting cable (higher for harder cables)\n                        // SCRAP: 5%, RESEARCH: 10%, FIBER: 25%, MILITARY: 40%, HVDC: 50%\n                        const anchorLossChance = cable.difficulty * 0.10;\n                        if (Math.random() < anchorLossChance && this.remainingAnchors > 0) {\n                            this.remainingAnchors--;\n                            this.anchorLost = true;\n                            this.anchorLostTime = $4ee2b06a9c1953f0$var$gameFrame;\n                            this.anchorLossReason = 'cable'; // Lost due to cable cutting\n                            $4ee2b06a9c1953f0$var$tanker.chainLength = 0; // Anchor is lost, chain goes to zero\n                            // Play alarm sound\n                            $4ee2b06a9c1953f0$var$alarm1.volume = 0.3;\n                            $4ee2b06a9c1953f0$var$alarm1.play().catch(()=>{});\n                            console.log(`Anchor lost from cable! Remaining: ${this.remainingAnchors}`);\n                        }\n                        // Play appropriate sound based on cable reward\n                        if (cable.reward >= 4) {\n                            // High value cables - louder, more distinct sound\n                            $4ee2b06a9c1953f0$var$metal3.volume = 0.25;\n                            $4ee2b06a9c1953f0$var$metal3.play().catch(()=>{});\n                            setTimeout(()=>{\n                                $4ee2b06a9c1953f0$var$metal4.volume = 0.2;\n                                $4ee2b06a9c1953f0$var$metal4.play().catch(()=>{});\n                            }, 100);\n                        } else if (cable.reward >= 2) {\n                            // Medium value\n                            $4ee2b06a9c1953f0$var$metal3.volume = 0.15;\n                            $4ee2b06a9c1953f0$var$metal3.play().catch(()=>{});\n                        } else {\n                            // Low value - subtle sound\n                            $4ee2b06a9c1953f0$var$metal1.volume = 0.1;\n                            $4ee2b06a9c1953f0$var$metal1.play().catch(()=>{});\n                        }\n                    }\n                }\n            }\n            // Check if anchor is in critical danger zone (>5x depth) for too long\n            // (anchorLossThreshold already defined above in cable cutting logic)\n            if ($4ee2b06a9c1953f0$var$tanker.chainLength >= this.depth * 5) {\n                // Anchor is critically deep\n                if (this.anchorDangerStartTime === 0) // Just entered danger zone\n                this.anchorDangerStartTime = $4ee2b06a9c1953f0$var$gameFrame;\n                else if ($4ee2b06a9c1953f0$var$gameFrame - this.anchorDangerStartTime > 300 && this.remainingAnchors > 0) {\n                    // Been in danger zone for 5 seconds (300 frames) - lose anchor!\n                    this.remainingAnchors--;\n                    this.anchorLost = true;\n                    this.anchorLostTime = $4ee2b06a9c1953f0$var$gameFrame;\n                    this.anchorLossReason = 'depth'; // Lost due to being too deep\n                    $4ee2b06a9c1953f0$var$tanker.chainLength = 0; // Anchor is lost\n                    this.anchorDangerStartTime = 0; // Reset timer\n                    // Play alarm sound\n                    $4ee2b06a9c1953f0$var$alarm1.volume = 0.3;\n                    $4ee2b06a9c1953f0$var$alarm1.play().catch(()=>{});\n                    console.log(`Anchor lost from depth! Remaining: ${this.remainingAnchors}`);\n                }\n            } else // Not in danger zone, reset timer\n            this.anchorDangerStartTime = 0;\n        }\n    }\n}\nconst $4ee2b06a9c1953f0$var$hud = new $4ee2b06a9c1953f0$var$Hud();\nfunction $4ee2b06a9c1953f0$var$createHud() {\n    $4ee2b06a9c1953f0$var$hud.update();\n}\nfunction $4ee2b06a9c1953f0$var$drawHUD() {\n    // Set up HUD styling\n    $4ee2b06a9c1953f0$var$ctx.save();\n    // Cable cut notification banner (center top)\n    if ($4ee2b06a9c1953f0$var$hud.lastCableCut && $4ee2b06a9c1953f0$var$gameFrame - $4ee2b06a9c1953f0$var$hud.lastCableTime < 1800) {\n        const elapsed = $4ee2b06a9c1953f0$var$gameFrame - $4ee2b06a9c1953f0$var$hud.lastCableTime;\n        const opacity = elapsed < 1740 ? 1.0 : (1800 - elapsed) / 60; // Fade out in last 1s\n        const bannerWidth = 400;\n        const bannerHeight = 70;\n        const bannerX = ($4ee2b06a9c1953f0$var$canvas.width - bannerWidth) / 2;\n        const bannerY = 20;\n        // Background\n        $4ee2b06a9c1953f0$var$ctx.globalAlpha = opacity * 0.95;\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = 'rgba(10, 26, 36, 0.95)';\n        $4ee2b06a9c1953f0$var$ctx.fillRect(bannerX, bannerY, bannerWidth, bannerHeight);\n        // Border with cable color\n        $4ee2b06a9c1953f0$var$ctx.strokeStyle = $4ee2b06a9c1953f0$var$hud.lastCableCut.color;\n        $4ee2b06a9c1953f0$var$ctx.lineWidth = 3;\n        $4ee2b06a9c1953f0$var$ctx.strokeRect(bannerX, bannerY, bannerWidth, bannerHeight);\n        // Title\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#a8f088';\n        $4ee2b06a9c1953f0$var$ctx.font = 'bold 13px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.textAlign = 'center';\n        $4ee2b06a9c1953f0$var$ctx.fillText(\"\\u2693 CABLE DAMAGED\", bannerX + bannerWidth / 2, bannerY + 20);\n        // Cable type name\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = $4ee2b06a9c1953f0$var$hud.lastCableCut.color;\n        $4ee2b06a9c1953f0$var$ctx.font = 'bold 16px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillText($4ee2b06a9c1953f0$var$hud.lastCableCut.name.toUpperCase(), bannerX + bannerWidth / 2, bannerY + 42);\n        // Stats (Reward & Risk)\n        $4ee2b06a9c1953f0$var$ctx.font = '11px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#e8e8d8';\n        const rewardStars = \"\\u2605\".repeat($4ee2b06a9c1953f0$var$hud.lastCableCut.reward);\n        const riskLevel = $4ee2b06a9c1953f0$var$hud.lastCableCut.risk >= 4 ? 'HIGH RISK' : $4ee2b06a9c1953f0$var$hud.lastCableCut.risk >= 3 ? 'MEDIUM' : 'LOW RISK';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`Value: ${rewardStars} | ${riskLevel}`, bannerX + bannerWidth / 2, bannerY + 60);\n        $4ee2b06a9c1953f0$var$ctx.globalAlpha = 1.0;\n        $4ee2b06a9c1953f0$var$ctx.textAlign = 'left';\n    }\n    // Anchor lost notification banner (center top, below cable notification)\n    if ($4ee2b06a9c1953f0$var$hud.anchorLost && $4ee2b06a9c1953f0$var$gameFrame - $4ee2b06a9c1953f0$var$hud.anchorLostTime < 1800) {\n        const elapsed = $4ee2b06a9c1953f0$var$gameFrame - $4ee2b06a9c1953f0$var$hud.anchorLostTime;\n        const opacity = elapsed < 1740 ? 1.0 : (1800 - elapsed) / 60; // Fade out in last 1s\n        const bannerWidth = 450;\n        const bannerHeight = 80;\n        const bannerX = ($4ee2b06a9c1953f0$var$canvas.width - bannerWidth) / 2;\n        const bannerY = 100; // Below cable notification\n        // Background\n        $4ee2b06a9c1953f0$var$ctx.globalAlpha = opacity * 0.95;\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = 'rgba(139, 0, 0, 0.95)'; // Dark red background\n        $4ee2b06a9c1953f0$var$ctx.fillRect(bannerX, bannerY, bannerWidth, bannerHeight);\n        // Border\n        $4ee2b06a9c1953f0$var$ctx.strokeStyle = '#ff6b7a';\n        $4ee2b06a9c1953f0$var$ctx.lineWidth = 3;\n        $4ee2b06a9c1953f0$var$ctx.strokeRect(bannerX, bannerY, bannerWidth, bannerHeight);\n        // Warning icon and title\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#ff6b7a';\n        $4ee2b06a9c1953f0$var$ctx.font = 'bold 18px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.textAlign = 'center';\n        $4ee2b06a9c1953f0$var$ctx.fillText(\"\\u26A0 ANCHOR LOST! \\u26A0\", bannerX + bannerWidth / 2, bannerY + 25);\n        // Message (different based on loss reason)\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#e8e8d8';\n        $4ee2b06a9c1953f0$var$ctx.font = 'bold 14px sans-serif';\n        const lossMessage = $4ee2b06a9c1953f0$var$hud.anchorLossReason === 'cable' ? 'Cable was too strong!' : 'Anchor stayed too deep!';\n        $4ee2b06a9c1953f0$var$ctx.fillText(lossMessage, bannerX + bannerWidth / 2, bannerY + 48);\n        // Remaining anchors\n        $4ee2b06a9c1953f0$var$ctx.font = '12px sans-serif';\n        const anchorText = $4ee2b06a9c1953f0$var$hud.remainingAnchors > 0 ? `${$4ee2b06a9c1953f0$var$hud.remainingAnchors} anchor${$4ee2b06a9c1953f0$var$hud.remainingAnchors === 1 ? '' : 's'} remaining` : 'NO ANCHORS LEFT - MISSION FAILED!';\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = $4ee2b06a9c1953f0$var$hud.remainingAnchors > 0 ? '#fffa80' : '#ff6b7a';\n        $4ee2b06a9c1953f0$var$ctx.fillText(anchorText, bannerX + bannerWidth / 2, bannerY + 68);\n        $4ee2b06a9c1953f0$var$ctx.globalAlpha = 1.0;\n        $4ee2b06a9c1953f0$var$ctx.textAlign = 'left';\n    }\n    // Mission success notification banner (center, prominent)\n    if ($4ee2b06a9c1953f0$var$hud.missionSuccess && $4ee2b06a9c1953f0$var$gameFrame - $4ee2b06a9c1953f0$var$hud.successTime < 3600) {\n        const elapsed = $4ee2b06a9c1953f0$var$gameFrame - $4ee2b06a9c1953f0$var$hud.successTime;\n        const opacity = elapsed < 3540 ? 1.0 : (3600 - elapsed) / 60; // Fade out in last 1s\n        const bannerWidth = 500;\n        const bannerHeight = 100;\n        const bannerX = ($4ee2b06a9c1953f0$var$canvas.width - bannerWidth) / 2;\n        const bannerY = 190; // Center of screen\n        // Background with green glow\n        $4ee2b06a9c1953f0$var$ctx.globalAlpha = opacity * 0.98;\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = 'rgba(42, 133, 149, 0.98)'; // Teal/cyan background\n        $4ee2b06a9c1953f0$var$ctx.fillRect(bannerX, bannerY, bannerWidth, bannerHeight);\n        // Border\n        $4ee2b06a9c1953f0$var$ctx.strokeStyle = '#a8f088';\n        $4ee2b06a9c1953f0$var$ctx.lineWidth = 4;\n        $4ee2b06a9c1953f0$var$ctx.strokeRect(bannerX, bannerY, bannerWidth, bannerHeight);\n        // Success icon and title\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#a8f088';\n        $4ee2b06a9c1953f0$var$ctx.font = 'bold 24px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.textAlign = 'center';\n        $4ee2b06a9c1953f0$var$ctx.fillText(\"\\u2605 MISSION SUCCESS! \\u2605\", bannerX + bannerWidth / 2, bannerY + 30);\n        // Cable name\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = $4ee2b06a9c1953f0$var$hud.lastCableCut.color;\n        $4ee2b06a9c1953f0$var$ctx.font = 'bold 18px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillText($4ee2b06a9c1953f0$var$hud.lastCableCut.name.toUpperCase() + ' SEVERED', bannerX + bannerWidth / 2, bannerY + 56);\n        // Message\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#e8e8d8';\n        $4ee2b06a9c1953f0$var$ctx.font = 'bold 14px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillText('Critical infrastructure disrupted!', bannerX + bannerWidth / 2, bannerY + 80);\n        $4ee2b06a9c1953f0$var$ctx.globalAlpha = 1.0;\n        $4ee2b06a9c1953f0$var$ctx.textAlign = 'left';\n    }\n    // Left side - Mission stats (simplified)\n    const leftX = 20;\n    // Use dynamic optimal range\n    const minOptimal = Math.floor($4ee2b06a9c1953f0$var$hud.depth * ($4ee2b06a9c1953f0$var$hud.optimalCenterDepth - $4ee2b06a9c1953f0$var$hud.optimalVariance));\n    const maxOptimal = Math.floor($4ee2b06a9c1953f0$var$hud.depth * ($4ee2b06a9c1953f0$var$hud.optimalCenterDepth + $4ee2b06a9c1953f0$var$hud.optimalVariance));\n    const anchorInSweetSpot = $4ee2b06a9c1953f0$var$hud.isAnchorDown;\n    // Danger zone calculations (shared across HUD elements)\n    const anchorLossThreshold = $4ee2b06a9c1953f0$var$hud.depth * 5;\n    const dangerZoneEnd = $4ee2b06a9c1953f0$var$hud.depth * 7; // Red zone extends to bottom of gauge\n    const inDangerZone = $4ee2b06a9c1953f0$var$tanker.chainLength > maxOptimal && $4ee2b06a9c1953f0$var$tanker.chainLength <= dangerZoneEnd;\n    // Display remaining anchors prominently\n    $4ee2b06a9c1953f0$var$ctx.fillStyle = '#e8e8d8';\n    $4ee2b06a9c1953f0$var$ctx.font = 'bold 14px sans-serif';\n    const anchorDisplay = \"\\u2693\".repeat($4ee2b06a9c1953f0$var$hud.remainingAnchors) + \"\\u2717\".repeat(2 - $4ee2b06a9c1953f0$var$hud.remainingAnchors);\n    $4ee2b06a9c1953f0$var$ctx.fillText(`Anchors: ${anchorDisplay} | Cables: ${$4ee2b06a9c1953f0$var$hud.cablesCut}`, leftX, 30);\n    // Debug: Log anchor count when it changes\n    if ($4ee2b06a9c1953f0$var$gameFrame % 60 === 0) console.log(`Frame ${$4ee2b06a9c1953f0$var$gameFrame}: Anchors remaining = ${$4ee2b06a9c1953f0$var$hud.remainingAnchors}, Display = ${anchorDisplay}`);\n    // Anchor status with proper states\n    $4ee2b06a9c1953f0$var$ctx.font = 'bold 15px sans-serif';\n    if ($4ee2b06a9c1953f0$var$tanker.chainLength >= anchorLossThreshold) {\n        // State 6: Critical danger - anchor too deep, about to be lost\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#ff6b7a';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`\\u{26A0} ANCHOR DANGER`, leftX, 60);\n        $4ee2b06a9c1953f0$var$ctx.font = '12px sans-serif';\n        // Show countdown timer if in danger zone\n        if ($4ee2b06a9c1953f0$var$hud.anchorDangerStartTime > 0) {\n            const timeInDanger = $4ee2b06a9c1953f0$var$gameFrame - $4ee2b06a9c1953f0$var$hud.anchorDangerStartTime;\n            const timeRemaining = Math.max(0, 300 - timeInDanger);\n            const secondsRemaining = Math.ceil(timeRemaining / 60);\n            $4ee2b06a9c1953f0$var$ctx.fillText(`ANCHOR LOST IN ${secondsRemaining}s!`, leftX, 80);\n        } else $4ee2b06a9c1953f0$var$ctx.fillText(`TOO DEEP! Reel up now!`, leftX, 80);\n    } else if (inDangerZone) {\n        // State 5: Red zone - too deep, reduced cable cutting efficiency\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#ffa940';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`\\u{26A0} TOO DEEP`, leftX, 60);\n        $4ee2b06a9c1953f0$var$ctx.font = '12px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`Low efficiency - optimal: ${minOptimal}-${maxOptimal}m`, leftX, 80);\n    } else if ($4ee2b06a9c1953f0$var$tanker.chainLength === 0) {\n        // State 1: Anchor up - not deployed\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#5a8ca8';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`ANCHOR UP`, leftX, 60);\n        $4ee2b06a9c1953f0$var$ctx.font = '12px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`Deploy to drag seabed`, leftX, 80);\n    } else if ($4ee2b06a9c1953f0$var$tanker.chainLength < $4ee2b06a9c1953f0$var$hud.depth) {\n        // State 2: Anchor lowered - deployed but not touching seabed\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#5a8ca8';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`ANCHOR LOWERED`, leftX, 60);\n        $4ee2b06a9c1953f0$var$ctx.font = '12px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`Need ${$4ee2b06a9c1953f0$var$hud.depth - $4ee2b06a9c1953f0$var$tanker.chainLength}m more`, leftX, 80);\n    } else if (anchorInSweetSpot) {\n        // State 4: Dragging at optimal depth (green zone)\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#a8f088';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`\\u{2693} DRAGGING`, leftX, 60);\n        $4ee2b06a9c1953f0$var$ctx.font = '13px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`${$4ee2b06a9c1953f0$var$hud.cablesCut} cables | ${($4ee2b06a9c1953f0$var$hud.draggedInMeters / 1000).toFixed(1)}km`, leftX, 80);\n    } else {\n        // State 3: Dragging - touching seabed but not in optimal range\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#fffa80';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`\\u{26A0} DRAGGING`, leftX, 60);\n        $4ee2b06a9c1953f0$var$ctx.font = '12px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`Target: ${minOptimal}-${maxOptimal}m`, leftX, 80);\n    }\n    // Right side - Detection risk meter\n    const meterWidth = 180;\n    const meterHeight = 24;\n    const meterX = $4ee2b06a9c1953f0$var$canvas.width - meterWidth - 20;\n    const meterY = 20;\n    // Detection Risk Label\n    $4ee2b06a9c1953f0$var$ctx.font = 'bold 13px sans-serif';\n    $4ee2b06a9c1953f0$var$ctx.fillStyle = '#e8e8d8';\n    $4ee2b06a9c1953f0$var$ctx.fillText('DETECTION', meterX, meterY - 6);\n    // Meter background\n    $4ee2b06a9c1953f0$var$ctx.fillStyle = 'rgba(21, 38, 47, 0.8)';\n    $4ee2b06a9c1953f0$var$ctx.fillRect(meterX, meterY, meterWidth, meterHeight);\n    // Risk bar color based on level\n    let riskColor;\n    if ($4ee2b06a9c1953f0$var$detectionRisk < 30) riskColor = '#a8f088'; // Green - safe\n    else if ($4ee2b06a9c1953f0$var$detectionRisk < 60) riskColor = '#fffa80'; // Yellow - caution\n    else riskColor = '#ff6b7a'; // Red - danger\n    // Fill risk meter\n    const riskWidth = $4ee2b06a9c1953f0$var$detectionRisk / 100 * meterWidth;\n    $4ee2b06a9c1953f0$var$ctx.fillStyle = riskColor;\n    $4ee2b06a9c1953f0$var$ctx.fillRect(meterX, meterY, riskWidth, meterHeight);\n    // Meter border\n    $4ee2b06a9c1953f0$var$ctx.strokeStyle = '#5a8ca8';\n    $4ee2b06a9c1953f0$var$ctx.lineWidth = 2;\n    $4ee2b06a9c1953f0$var$ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);\n    // Risk percentage text\n    $4ee2b06a9c1953f0$var$ctx.font = 'bold 14px sans-serif';\n    $4ee2b06a9c1953f0$var$ctx.fillStyle = '#0a1a24';\n    $4ee2b06a9c1953f0$var$ctx.textAlign = 'center';\n    if ($4ee2b06a9c1953f0$var$detectionRisk > 15) $4ee2b06a9c1953f0$var$ctx.fillText(`${Math.round($4ee2b06a9c1953f0$var$detectionRisk)}%`, meterX + meterWidth / 2, meterY + 18);\n    $4ee2b06a9c1953f0$var$ctx.textAlign = 'left';\n    // Risk status text\n    $4ee2b06a9c1953f0$var$ctx.font = '11px sans-serif';\n    $4ee2b06a9c1953f0$var$ctx.fillStyle = riskColor;\n    let statusText = 'CLEAR';\n    if ($4ee2b06a9c1953f0$var$detectionRisk >= 60) statusText = 'DANGER';\n    else if ($4ee2b06a9c1953f0$var$detectionRisk >= 30) statusText = 'CAUTION';\n    $4ee2b06a9c1953f0$var$ctx.textAlign = 'center';\n    $4ee2b06a9c1953f0$var$ctx.fillText(statusText, meterX + meterWidth / 2, meterY + meterHeight + 14);\n    $4ee2b06a9c1953f0$var$ctx.textAlign = 'left';\n    // Chain depth gauge (right side, below detection meter)\n    const gaugeX = $4ee2b06a9c1953f0$var$canvas.width - 70;\n    const gaugeY = 70;\n    const gaugeHeight = 140;\n    const gaugeWidth = 35;\n    // Fixed scale based on seabed depth: always show 0 to 7x depth\n    // This covers: seabed (1x ~14%), green zone (~38-47%), red danger zone (50-100%, lower half)\n    const gaugeMaxValue = $4ee2b06a9c1953f0$var$hud.depth * 7;\n    // Label with current chain length\n    $4ee2b06a9c1953f0$var$ctx.font = 'bold 10px sans-serif';\n    $4ee2b06a9c1953f0$var$ctx.fillStyle = '#e8e8d8';\n    $4ee2b06a9c1953f0$var$ctx.textAlign = 'center';\n    $4ee2b06a9c1953f0$var$ctx.fillText('CHAIN', gaugeX + gaugeWidth / 2, gaugeY - 8);\n    // Gauge background\n    $4ee2b06a9c1953f0$var$ctx.fillStyle = 'rgba(21, 38, 47, 0.8)';\n    $4ee2b06a9c1953f0$var$ctx.fillRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);\n    // Seabed depth reference line\n    const seabedPos = $4ee2b06a9c1953f0$var$hud.depth / gaugeMaxValue * gaugeHeight;\n    if (seabedPos <= gaugeHeight) {\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = 'rgba(42, 133, 149, 0.4)';\n        $4ee2b06a9c1953f0$var$ctx.fillRect(gaugeX, gaugeY + seabedPos - 1, gaugeWidth, 2);\n    }\n    // Optimal cutting zone (green zone - dynamically calculated based on cable depth variance)\n    // Typically ~2.7x-3.3x depth (center 3.0x  0.3x variance)\n    const minOptimalPos = Math.min(minOptimal / gaugeMaxValue * gaugeHeight, gaugeHeight);\n    const maxOptimalPos = Math.min(maxOptimal / gaugeMaxValue * gaugeHeight, gaugeHeight);\n    // Orange transition zone (between green and red)\n    const orangeZoneStart = maxOptimal; // Starts right after green zone ends (~3.3x)\n    const orangeZoneEnd = $4ee2b06a9c1953f0$var$hud.depth * 3.5; // Ends where red zone starts (3.5x)\n    const orangeZoneStartPos = Math.min(orangeZoneStart / gaugeMaxValue * gaugeHeight, gaugeHeight);\n    const orangeZoneEndPos = Math.min(orangeZoneEnd / gaugeMaxValue * gaugeHeight, gaugeHeight);\n    // Danger zone (red zone in lower HALF of gauge - starts at 3.5x depth)\n    // Gauge shows 0 to 7x depth, so 3.5x depth is exactly halfway\n    const dangerZoneStart = $4ee2b06a9c1953f0$var$hud.depth * 3.5; // Start red zone at halfway point\n    const dangerZoneStartPos = Math.min(dangerZoneStart / gaugeMaxValue * gaugeHeight, gaugeHeight);\n    const dangerZoneEndPos = gaugeHeight; // Red zone extends to bottom of gauge (7x depth)\n    // Always draw green zone (reference zone for optimal cable cutting)\n    if (maxOptimalPos > minOptimalPos) {\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = 'rgba(168, 240, 136, 0.25)';\n        $4ee2b06a9c1953f0$var$ctx.fillRect(gaugeX, gaugeY + minOptimalPos, gaugeWidth, maxOptimalPos - minOptimalPos);\n        // Draw zone boundaries\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#a8f088';\n        if (minOptimalPos < gaugeHeight) $4ee2b06a9c1953f0$var$ctx.fillRect(gaugeX, gaugeY + minOptimalPos - 1, gaugeWidth, 2);\n        if (maxOptimalPos < gaugeHeight) $4ee2b06a9c1953f0$var$ctx.fillRect(gaugeX, gaugeY + maxOptimalPos - 1, gaugeWidth, 2);\n    }\n    // Draw orange transition zone (between green and red)\n    if (orangeZoneEndPos > orangeZoneStartPos && orangeZoneStartPos < gaugeHeight) {\n        const zoneHeight = orangeZoneEndPos - orangeZoneStartPos;\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = 'rgba(255, 169, 64, 0.25)'; // Slight orange/amber\n        $4ee2b06a9c1953f0$var$ctx.fillRect(gaugeX, gaugeY + orangeZoneStartPos, gaugeWidth, zoneHeight);\n        // Draw orange zone boundary at the top\n        if (orangeZoneStartPos < gaugeHeight) {\n            $4ee2b06a9c1953f0$var$ctx.fillStyle = '#ffa940';\n            $4ee2b06a9c1953f0$var$ctx.fillRect(gaugeX, gaugeY + orangeZoneStartPos - 1, gaugeWidth, 2);\n        }\n    }\n    // Always draw red danger zone (reference zone for too deep)\n    if (dangerZoneEndPos > dangerZoneStartPos && dangerZoneStartPos < gaugeHeight) {\n        const zoneHeight = dangerZoneEndPos - dangerZoneStartPos;\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = 'rgba(255, 107, 122, 0.3)';\n        $4ee2b06a9c1953f0$var$ctx.fillRect(gaugeX, gaugeY + dangerZoneStartPos, gaugeWidth, zoneHeight);\n        // Draw danger zone boundary at the top of red zone\n        if (dangerZoneStartPos < gaugeHeight) {\n            $4ee2b06a9c1953f0$var$ctx.fillStyle = '#ff6b7a';\n            $4ee2b06a9c1953f0$var$ctx.fillRect(gaugeX, gaugeY + dangerZoneStartPos - 1, gaugeWidth, 2);\n        }\n    }\n    // Current anchor position indicator (using inDangerZone from above)\n    const anchorPos = Math.min($4ee2b06a9c1953f0$var$tanker.chainLength / gaugeMaxValue * gaugeHeight, gaugeHeight);\n    $4ee2b06a9c1953f0$var$ctx.beginPath();\n    $4ee2b06a9c1953f0$var$ctx.moveTo(gaugeX - 5, gaugeY + anchorPos);\n    $4ee2b06a9c1953f0$var$ctx.lineTo(gaugeX + gaugeWidth + 5, gaugeY + anchorPos);\n    $4ee2b06a9c1953f0$var$ctx.lineWidth = 3;\n    // Red if in danger zone, green if in sweet spot, blue otherwise\n    $4ee2b06a9c1953f0$var$ctx.strokeStyle = inDangerZone ? '#ff6b7a' : anchorInSweetSpot ? '#a8f088' : '#5a8ca8';\n    $4ee2b06a9c1953f0$var$ctx.stroke();\n    // Gauge border\n    $4ee2b06a9c1953f0$var$ctx.strokeStyle = '#5a8ca8';\n    $4ee2b06a9c1953f0$var$ctx.lineWidth = 2;\n    $4ee2b06a9c1953f0$var$ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);\n    // Current chain length below gauge\n    $4ee2b06a9c1953f0$var$ctx.font = '10px sans-serif';\n    $4ee2b06a9c1953f0$var$ctx.fillStyle = '#e8e8d8';\n    $4ee2b06a9c1953f0$var$ctx.fillText(`${$4ee2b06a9c1953f0$var$tanker.chainLength}m`, gaugeX + gaugeWidth / 2, gaugeY + gaugeHeight + 12);\n    // Seabed depth graph (bottom left) - 50% past, 50% future\n    if ($4ee2b06a9c1953f0$var$hud.depthHistory.length > 0 || $4ee2b06a9c1953f0$var$hud.futureDepths.length > 0) {\n        const graphWidth = 180;\n        const graphHeight = 45;\n        const graphX = 20;\n        const graphY = $4ee2b06a9c1953f0$var$canvas.height - graphHeight - 20;\n        // Label\n        $4ee2b06a9c1953f0$var$ctx.font = 'bold 10px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#e8e8d8';\n        $4ee2b06a9c1953f0$var$ctx.textAlign = 'left';\n        $4ee2b06a9c1953f0$var$ctx.fillText('SEABED', graphX, graphY - 8);\n        // Background\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = 'rgba(21, 38, 47, 0.8)';\n        $4ee2b06a9c1953f0$var$ctx.fillRect(graphX, graphY, graphWidth, graphHeight);\n        // Combine past, current, and future depths\n        const allDepths = [\n            ...$4ee2b06a9c1953f0$var$hud.depthHistory,\n            $4ee2b06a9c1953f0$var$hud.depth,\n            ...$4ee2b06a9c1953f0$var$hud.futureDepths\n        ];\n        const totalPoints = allDepths.length;\n        const shipIndex = $4ee2b06a9c1953f0$var$hud.depthHistory.length; // Ship is right after history\n        const maxDepth = Math.max(...allDepths, 470);\n        const minDepth = Math.min(...allDepths, 20);\n        const depthRange = maxDepth - minDepth || 100; // Avoid division by zero\n        // Draw past depths (left half, dimmer)\n        $4ee2b06a9c1953f0$var$ctx.strokeStyle = 'rgba(42, 133, 149, 0.5)'; // Dimmer for past\n        $4ee2b06a9c1953f0$var$ctx.lineWidth = 2;\n        $4ee2b06a9c1953f0$var$ctx.beginPath();\n        for(let i = 0; i < totalPoints; i++){\n            const x = graphX + i / (totalPoints - 1) * graphWidth;\n            const normalizedDepth = (allDepths[i] - minDepth) / depthRange;\n            const y = graphY + graphHeight - normalizedDepth * graphHeight;\n            // Change color at ship position\n            if (i === shipIndex) {\n                $4ee2b06a9c1953f0$var$ctx.stroke(); // Finish past line\n                $4ee2b06a9c1953f0$var$ctx.strokeStyle = '#2a8595'; // Brighter for future\n                $4ee2b06a9c1953f0$var$ctx.beginPath();\n                $4ee2b06a9c1953f0$var$ctx.moveTo(x, y);\n            } else if (i === 0) $4ee2b06a9c1953f0$var$ctx.moveTo(x, y);\n            else $4ee2b06a9c1953f0$var$ctx.lineTo(x, y);\n        }\n        $4ee2b06a9c1953f0$var$ctx.stroke();\n        // Ship position indicator (vertical line at center)\n        const shipX = graphX + shipIndex / (totalPoints - 1) * graphWidth;\n        $4ee2b06a9c1953f0$var$ctx.strokeStyle = 'rgba(255, 169, 64, 0.6)'; // Orange line for ship position\n        $4ee2b06a9c1953f0$var$ctx.lineWidth = 2;\n        $4ee2b06a9c1953f0$var$ctx.setLineDash([\n            4,\n            4\n        ]); // Dashed line\n        $4ee2b06a9c1953f0$var$ctx.beginPath();\n        $4ee2b06a9c1953f0$var$ctx.moveTo(shipX, graphY);\n        $4ee2b06a9c1953f0$var$ctx.lineTo(shipX, graphY + graphHeight);\n        $4ee2b06a9c1953f0$var$ctx.stroke();\n        $4ee2b06a9c1953f0$var$ctx.setLineDash([]); // Reset to solid line\n        // Current depth indicator (dot at ship position)\n        const currentNormalized = ($4ee2b06a9c1953f0$var$hud.depth - minDepth) / depthRange;\n        const currentY = graphY + graphHeight - currentNormalized * graphHeight;\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#ffa940'; // Orange dot\n        $4ee2b06a9c1953f0$var$ctx.beginPath();\n        $4ee2b06a9c1953f0$var$ctx.arc(shipX, currentY, 4, 0, Math.PI * 2);\n        $4ee2b06a9c1953f0$var$ctx.fill();\n        // Outline for better visibility\n        $4ee2b06a9c1953f0$var$ctx.strokeStyle = '#e8e8d8';\n        $4ee2b06a9c1953f0$var$ctx.lineWidth = 1;\n        $4ee2b06a9c1953f0$var$ctx.stroke();\n        // Border\n        $4ee2b06a9c1953f0$var$ctx.strokeStyle = '#5a8ca8';\n        $4ee2b06a9c1953f0$var$ctx.lineWidth = 2;\n        $4ee2b06a9c1953f0$var$ctx.strokeRect(graphX, graphY, graphWidth, graphHeight);\n        // Current depth text\n        $4ee2b06a9c1953f0$var$ctx.font = '10px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#e8e8d8';\n        $4ee2b06a9c1953f0$var$ctx.textAlign = 'left';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`Depth: ${$4ee2b06a9c1953f0$var$hud.depth}m`, graphX, graphY + graphHeight + 12);\n    }\n    // Cable breakdown stats (bottom right)\n    if ($4ee2b06a9c1953f0$var$hud.cablesCut > 0) {\n        const statsX = $4ee2b06a9c1953f0$var$canvas.width - 200;\n        const statsY = $4ee2b06a9c1953f0$var$canvas.height - 130;\n        const statsWidth = 180;\n        const statsHeight = 110;\n        // Background\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = 'rgba(21, 38, 47, 0.8)';\n        $4ee2b06a9c1953f0$var$ctx.fillRect(statsX, statsY, statsWidth, statsHeight);\n        // Border\n        $4ee2b06a9c1953f0$var$ctx.strokeStyle = '#5a8ca8';\n        $4ee2b06a9c1953f0$var$ctx.lineWidth = 2;\n        $4ee2b06a9c1953f0$var$ctx.strokeRect(statsX, statsY, statsWidth, statsHeight);\n        // Title\n        $4ee2b06a9c1953f0$var$ctx.font = 'bold 10px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#e8e8d8';\n        $4ee2b06a9c1953f0$var$ctx.textAlign = 'left';\n        $4ee2b06a9c1953f0$var$ctx.fillText('CABLES DAMAGED', statsX + 10, statsY + 15);\n        // Cable type breakdown\n        $4ee2b06a9c1953f0$var$ctx.font = '10px sans-serif';\n        let yOffset = 30;\n        const cableOrder = [\n            'HVDC',\n            'MILITARY',\n            'FIBER',\n            'RESEARCH',\n            'SCRAP'\n        ];\n        cableOrder.forEach((type)=>{\n            const count = $4ee2b06a9c1953f0$var$hud.cablesByType[type];\n            if (count > 0) {\n                const cable = $4ee2b06a9c1953f0$var$CABLE_TYPES[type];\n                $4ee2b06a9c1953f0$var$ctx.fillStyle = cable.color;\n                $4ee2b06a9c1953f0$var$ctx.fillText(`${count}\\xd7 ${cable.name}`, statsX + 10, statsY + yOffset);\n                yOffset += 14;\n            }\n        });\n        // Total\n        $4ee2b06a9c1953f0$var$ctx.font = 'bold 11px sans-serif';\n        $4ee2b06a9c1953f0$var$ctx.fillStyle = '#a8f088';\n        $4ee2b06a9c1953f0$var$ctx.fillText(`Total: ${$4ee2b06a9c1953f0$var$hud.cablesCut}`, statsX + 10, statsY + statsHeight - 10);\n    }\n    $4ee2b06a9c1953f0$var$ctx.textAlign = 'left';\n    $4ee2b06a9c1953f0$var$ctx.restore();\n}\nlet $4ee2b06a9c1953f0$var$backgroundSoundsStarted = false;\nfunction $4ee2b06a9c1953f0$var$backgroundSounds() {\n    if ($4ee2b06a9c1953f0$var$backgroundSoundsStarted) return; // Only start once\n    $4ee2b06a9c1953f0$var$music.volume = 0.75;\n    $4ee2b06a9c1953f0$var$music.play().catch((err)=>console.log('Music play failed:', err));\n    $4ee2b06a9c1953f0$var$wind1.volume = 0.005;\n    $4ee2b06a9c1953f0$var$wind1.play().catch((err)=>console.log('Wind play failed:', err));\n    $4ee2b06a9c1953f0$var$waves.volume = 0.05;\n    $4ee2b06a9c1953f0$var$waves.play().catch((err)=>console.log('Waves play failed:', err));\n    $4ee2b06a9c1953f0$var$ship.volume = 0.01;\n    $4ee2b06a9c1953f0$var$ship.play().catch((err)=>console.log('Ship play failed:', err));\n    $4ee2b06a9c1953f0$var$backgroundSoundsStarted = true;\n}\nfunction $4ee2b06a9c1953f0$var$randomCreaks() {\n    if ($4ee2b06a9c1953f0$var$gameFrame % $4ee2b06a9c1953f0$var$randomBetween(2000, 6000) === 0) {\n        const audioKey = `metal${$4ee2b06a9c1953f0$var$randomBetween(1, 5)}`;\n        const audio = $4ee2b06a9c1953f0$var$audioElements[audioKey];\n        if (audio) {\n            audio.volume = 0.1;\n            audio.play().catch(()=>{});\n        }\n    }\n}\nlet $4ee2b06a9c1953f0$var$animationId;\nfunction $4ee2b06a9c1953f0$var$animate() {\n    $4ee2b06a9c1953f0$var$ctx.clearRect(0, 0, $4ee2b06a9c1953f0$var$canvas.width, $4ee2b06a9c1953f0$var$canvas.height);\n    if (!$4ee2b06a9c1953f0$var$isPaused) {\n        $4ee2b06a9c1953f0$var$backgroundSounds();\n        $4ee2b06a9c1953f0$var$randomCreaks();\n        $4ee2b06a9c1953f0$var$createBackground();\n        $4ee2b06a9c1953f0$var$createHud();\n        $4ee2b06a9c1953f0$var$createTanker();\n        $4ee2b06a9c1953f0$var$createPatrols();\n        $4ee2b06a9c1953f0$var$updateParticles(); // Draw particle effects\n        $4ee2b06a9c1953f0$var$gameFrame++;\n    } else {\n        // Still draw static elements when paused\n        $4ee2b06a9c1953f0$var$createBackground();\n        $4ee2b06a9c1953f0$var$createTanker();\n        $4ee2b06a9c1953f0$var$createPatrols();\n    }\n    $4ee2b06a9c1953f0$var$drawHUD(); // Always draw HUD\n    // Win condition: Successfully cut a critical cable\n    if ($4ee2b06a9c1953f0$var$hud.missionSuccess) {\n        // Set success message\n        const successCable = document.getElementById('success-cable');\n        if ($4ee2b06a9c1953f0$var$hud.lastCableCut) successCable.textContent = `${$4ee2b06a9c1953f0$var$hud.lastCableCut.name.toUpperCase()} SEVERED`;\n        document.getElementById('success').style.display = 'flex';\n        cancelAnimationFrame($4ee2b06a9c1953f0$var$animationId);\n        return; // Stop the animation loop\n    } else if ($4ee2b06a9c1953f0$var$warnings > 1000 || $4ee2b06a9c1953f0$var$detectionRisk >= 100 || $4ee2b06a9c1953f0$var$hud.remainingAnchors <= 0) {\n        // Set failure message based on cause\n        const restartTitle = document.getElementById('restart-title');\n        const restartMessage = document.getElementById('restart-message');\n        if ($4ee2b06a9c1953f0$var$hud.remainingAnchors <= 0) {\n            restartTitle.textContent = \"\\u2693 NO ANCHORS LEFT\";\n            restartMessage.textContent = 'All anchors lost - Mission failed!';\n        } else if ($4ee2b06a9c1953f0$var$detectionRisk >= 100) {\n            restartTitle.textContent = \"\\u26A0 MISSION COMPROMISED\";\n            restartMessage.textContent = 'You were detected by patrol vessels';\n        } else {\n            restartTitle.textContent = \"\\u26A0 MISSION FAILED\";\n            restartMessage.textContent = 'Too many warnings from patrols';\n        }\n        document.getElementById('restart').style.display = 'flex';\n        cancelAnimationFrame($4ee2b06a9c1953f0$var$animationId);\n        return; // Stop the animation loop\n    }\n    // Continue the animation loop only if game is not over\n    $4ee2b06a9c1953f0$var$animationId = requestAnimationFrame($4ee2b06a9c1953f0$var$animate);\n}\n// Wait for DOM to be fully loaded\nif (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', $4ee2b06a9c1953f0$var$initGame);\nelse $4ee2b06a9c1953f0$var$initGame();\nfunction $4ee2b06a9c1953f0$var$initGame() {\n    console.log('=== Initializing game ===');\n    // Initialize overlays\n    const restartDiv = document.getElementById('restart');\n    const successDiv = document.getElementById('success');\n    const startDiv = document.getElementById('start');\n    if (restartDiv) restartDiv.style.display = 'none';\n    if (successDiv) successDiv.style.display = 'none';\n    // Play button\n    const playBtn = document.getElementById('play');\n    if (playBtn) {\n        console.log('Setting up play button');\n        playBtn.addEventListener('click', function(e) {\n            e.preventDefault();\n            e.stopPropagation();\n            console.log('Play button clicked - starting game');\n            if (startDiv) startDiv.style.display = 'none';\n            $4ee2b06a9c1953f0$var$animate();\n        }, true);\n    } else console.error('Play button not found!');\n    // Retry button\n    const replayBtn = document.getElementById('replay');\n    if (replayBtn) {\n        console.log('Setting up replay button');\n        replayBtn.addEventListener('click', function(e) {\n            e.preventDefault();\n            e.stopPropagation();\n            console.log('Retry Mission button clicked - reloading');\n            window.location.reload();\n        }, true);\n    } else console.error('Replay button not found!');\n    // New Mission button\n    const replaySuccessBtn = document.getElementById('replay-success');\n    if (replaySuccessBtn) {\n        console.log('Setting up replay-success button');\n        replaySuccessBtn.addEventListener('click', function(e) {\n            e.preventDefault();\n            e.stopPropagation();\n            console.log('New Mission button clicked - reloading');\n            window.location.reload();\n        }, true);\n        // Also add mousedown as backup\n        replaySuccessBtn.addEventListener('mousedown', function(e) {\n            console.log('New Mission mousedown event');\n        }, true);\n    } else console.error('Replay-success button not found!');\n    console.log('Game initialization complete');\n}\n// Handle fullscreen canvas resizing\ndocument.addEventListener('fullscreenchange', function() {\n    if (document.fullscreenElement) {\n        // Entering fullscreen - scale canvas while maintaining aspect ratio\n        const aspectRatio = $4ee2b06a9c1953f0$var$DEFAULT_WIDTH / $4ee2b06a9c1953f0$var$DEFAULT_HEIGHT; // 1.6\n        const viewportWidth = window.innerWidth;\n        const viewportHeight = window.innerHeight;\n        const viewportAspectRatio = viewportWidth / viewportHeight;\n        let newWidth, newHeight;\n        if (viewportAspectRatio > aspectRatio) {\n            // Viewport is wider - scale by height\n            newHeight = viewportHeight;\n            newWidth = newHeight * aspectRatio;\n        } else {\n            // Viewport is taller - scale by width\n            newWidth = viewportWidth;\n            newHeight = newWidth / aspectRatio;\n        }\n        $4ee2b06a9c1953f0$var$canvas.style.width = newWidth + 'px';\n        $4ee2b06a9c1953f0$var$canvas.style.height = newHeight + 'px';\n        // Keep internal resolution the same\n        $4ee2b06a9c1953f0$var$canvas.width = $4ee2b06a9c1953f0$var$DEFAULT_WIDTH;\n        $4ee2b06a9c1953f0$var$canvas.height = $4ee2b06a9c1953f0$var$DEFAULT_HEIGHT;\n    } else {\n        // Exiting fullscreen - reset styles\n        $4ee2b06a9c1953f0$var$canvas.style.width = '800px';\n        $4ee2b06a9c1953f0$var$canvas.style.height = '500px';\n        $4ee2b06a9c1953f0$var$canvas.width = $4ee2b06a9c1953f0$var$DEFAULT_WIDTH;\n        $4ee2b06a9c1953f0$var$canvas.height = $4ee2b06a9c1953f0$var$DEFAULT_HEIGHT;\n    }\n    // Reset font size for text rendering\n    $4ee2b06a9c1953f0$var$ctx.font = '24px sans-serif';\n});\n\n\n//# sourceMappingURL=index.461ec126.js.map\n","\"use strict\";\n\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n  for (var i = 0; i < manifest.length - 1; i += 2) {\n    mapping.set(manifest[i], {\n      baseUrl: baseUrl,\n      path: manifest[i + 1]\n    });\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping.get(id);\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(new __parcel__URL__(\"\").toString(),JSON.parse(\"[\\\"4Zi2e\\\",\\\"index.461ec126.js\\\",\\\"id7cg\\\",\\\"bg.51ef01c9.png\\\",\\\"2eqI5\\\",\\\"patrol.9736c357.png\\\",\\\"lkgDT\\\",\\\"tanker-sprite-2.95dcef17.png\\\"]\"));","import bgImg from './images/bg.png';\nimport patrolImg from './images/patrol.png';\nimport tankerSprite from './images/tanker-sprite-2.png';\n\nconst canvas = document.getElementById('game-canvas');\nconst ctx = canvas.getContext('2d');\nconst DEFAULT_WIDTH = 800;\nconst DEFAULT_HEIGHT = 500;\ncanvas.width = DEFAULT_WIDTH;\ncanvas.height = DEFAULT_HEIGHT;\n\nconst TANKER_IMAGE_WIDTH = 344,\n  TANKER_IMAGE_HEIGHT = 52\n\nlet score = 0;\nlet gameFrame = 0;\nlet warnings = 0;\nconst gameSpeed = 1;\nlet previousChainLength = 0;\nlet isPaused = false;\nlet detectionRisk = 0; // 0-100 scale for patrol detection risk\nctx.font = '24px sans-serif'\n\n// Expose game state to window for cross-module access\nwindow.gameState = {\n  get isPaused() { return isPaused; },\n  set isPaused(value) {\n    isPaused = value;\n    // Pause/resume all audio when game is paused\n    if (isPaused) {\n      pauseAllAudio();\n    } else {\n      resumeAllAudio();\n    }\n  }\n};\n\n// Audio control functions\nfunction pauseAllAudio() {\n  const allAudio = document.querySelectorAll('audio');\n  allAudio.forEach(audio => {\n    if (!audio.paused) {\n      audio.pause();\n    }\n  });\n}\n\nfunction resumeAllAudio() {\n  // Only resume looping background audio, not one-shot sounds\n  music.play().catch(() => { });\n  wind1.play().catch(() => { });\n  waves.play().catch(() => { });\n  ship.play().catch(() => { });\n}\n\n// Audio elements map\nconst audioElements = {\n  metal1: document.getElementById('metal1'),\n  metal2: document.getElementById('metal2'),\n  metal3: document.getElementById('metal3'),\n  metal4: document.getElementById('metal4'),\n  metal5: document.getElementById('metal5')\n};\n\n// All other audio elements\nconst music = document.getElementById('music');\nconst wind1 = document.getElementById('wind1');\nconst waves = document.getElementById('waves');\nconst ship = document.getElementById('ship');\nconst winch1 = document.getElementById('winch1');\nconst winch5 = document.getElementById('winch5');\nconst winch8 = document.getElementById('winch8');\nconst scrape7 = document.getElementById('scrape7');\nconst alarm1 = document.getElementById('alarm1');\nconst splash = document.getElementById('splash');\n// Get metal sounds from audioElements for convenience\nconst metal1 = audioElements.metal1;\nconst metal2 = audioElements.metal2;\nconst metal3 = audioElements.metal3;\nconst metal4 = audioElements.metal4;\nconst metal5 = audioElements.metal5;\n\nconst targetPosition = {\n  x: canvas.width / 2 - (TANKER_IMAGE_WIDTH / 2),\n  y: canvas.height / 1.5,\n}\n\ndocument.addEventListener('keydown', function (e) {\n  e.preventDefault();\n  // Reel anchor up - slower (harder to pull up)\n  if (e.key === 'ArrowUp') {\n    tanker.chainLength = Math.max(0, tanker.chainLength - 5);\n    winch8.volume = 0.25;\n    winch8.play().catch(() => { });\n  }\n  // Lower anchor - faster (easier to drop) - only if anchors remain\n  if (e.key === 'ArrowDown' && hud.remainingAnchors > 0) {\n    tanker.chainLength = Math.min(tanker.chainLength + 20, tanker.chainLengthMax);\n    winch1.volume = 0.25;\n    winch1.play().catch(() => { });\n  }\n  // Back\n  if (e.key === 'ArrowLeft') {\n    targetPosition.x -= 5;\n  }\n  // Forward\n  if (e.key === 'ArrowRight') {\n    targetPosition.x += 20;\n  }\n})\n\n// Player\nconst tankerImage = new Image();\ntankerImage.src = tankerSprite;\n\nclass Tanker {\n  constructor() {\n    this.x = targetPosition.x;\n    this.y = targetPosition.y;\n    this.frameX = 0;\n    this.frameY = 0;\n    this.frame = 0;\n    this.spriteWidth = TANKER_IMAGE_WIDTH;\n    this.spriteHeight = TANKER_IMAGE_HEIGHT;\n    this.chainLength = 0;\n    this.chainLengthMax = 2000; // Increased to allow 4x depth (max depth ~470, so 4x ~1880)\n  }\n\n  update() {\n    const dx = this.x - targetPosition.x;\n    const dy = this.y - targetPosition.y;\n\n    // Calculate speed reduction based on anchor dragging\n    let speedMultiplier = 1.0; // Normal speed\n\n    // EXTREME slowdown when dragging through a cable (5 seconds after cable cut)\n    if (hud.lastCableCut && gameFrame - hud.lastCableTime < 300) {\n      // Nearly stopped: 2-8% speed depending on cable difficulty\n      const cableDifficulty = hud.lastCableCut.difficulty || 1;\n      speedMultiplier = 0.02 + (cableDifficulty * 0.012); // Harder cables = slightly more resistance\n    } else if (this.chainLength > 0) {\n      // Anchor is deployed - boat slows down\n      if (this.chainLength >= hud.depth) {\n        // Anchor is touching/dragging on seabed - dramatic slowdown\n        const dragAmount = this.chainLength - hud.depth;\n        const maxDrag = hud.depth * 4; // Max optimal range\n        const dragRatio = Math.min(dragAmount / maxDrag, 1.0);\n\n        // Speed reduces dramatically: 30% speed when just touching, down to 5% at max drag\n        speedMultiplier = 0.3 - (dragRatio * 0.25);\n      } else {\n        // Anchor deployed but not touching seabed - moderate slowdown based on chain length\n        const deployRatio = Math.min(this.chainLength / hud.depth, 1.0);\n        // Speed reduces from 100% to 50% as anchor gets closer to seabed\n        speedMultiplier = 1.0 - (deployRatio * 0.5);\n      }\n    }\n\n    // Apply speed with drag resistance\n    const effectiveSpeed = 100 / speedMultiplier;\n    if (targetPosition.x != this.x) {\n      this.x -= dx / effectiveSpeed;\n    }\n    if (targetPosition.y != this.y) {\n      this.y -= dy / effectiveSpeed;\n    }\n    if (gameFrame % 5 == 0) {\n      // Dynamic animation based on chain length relative to optimal range\n      const minOptimal = hud.depth * 2;\n      const maxOptimal = hud.depth * 4;\n      const inSweetSpot = this.chainLength >= minOptimal && this.chainLength <= maxOptimal;\n\n      if (this.chainLength < 10) {\n        // No anchor deployed\n        this.frameY = 0;\n        this.frameX = 0;\n      } else if (this.chainLength < minOptimal * 0.5) {\n        // Light deployment (< half of min optimal)\n        this.frameY = 1;\n        this.frameX = 0;\n      } else if (!inSweetSpot) {\n        // Moderate deployment (approaching or past sweet spot)\n        if (Math.random() <= 0.01) winch5.play().catch(() => { })\n        if (Math.random() <= 0.96) {\n          this.frameY = 0;\n          this.frameX = 1;\n        } else {\n          this.frameY = 0;\n          this.frameX = 2;\n        }\n      } else {\n        // In sweet spot (2x-4x depth)\n        if (Math.random() <= 0.8) {\n          this.frameY = 0;\n          this.frameX = 2;\n        } else {\n          this.frameY = 1;\n          this.frameX = 2;\n        }\n      }\n\n      // Scraping and creaking sounds when anchor is dragging on seabed\n      if (this.chainLength >= hud.depth) {\n        const dragAmount = this.chainLength - hud.depth;\n        const maxDrag = hud.depth * 4;\n        const dragRatio = Math.min(dragAmount / maxDrag, 1.0);\n\n        // More frequent sounds the more you drag: 5% base, up to 25% at max drag\n        const soundChance = 0.05 + (dragRatio * 0.20);\n\n        if (Math.random() <= soundChance) {\n          // Random metal creaking sounds\n          const metalSounds = [metal1, metal2, metal3, metal4, metal5];\n          const randomMetal = metalSounds[Math.floor(Math.random() * metalSounds.length)];\n          randomMetal.volume = 0.08 + (dragRatio * 0.12); // Louder with more drag\n          randomMetal.play().catch(() => { });\n\n          this.frameY = 1;\n          this.frameX = 2;\n        }\n\n        // Scraping sound at optimal dragging depth\n        if (hud.isAnchorDown && (Math.random() <= 0.08)) {\n          scrape7.volume = 0.12 + (dragRatio * 0.08);\n          scrape7.play().catch(() => { });\n        }\n      }\n    }\n  }\n  draw() {\n    ctx.drawImage(\n      tankerImage,\n      this.frameX * this.spriteWidth,\n      this.frameY * this.spriteHeight,\n      this.spriteWidth,\n      this.spriteHeight,\n      this.x,\n      this.y,\n      this.spriteWidth,\n      this.spriteHeight\n    );\n  }\n}\n\nconst tanker = new Tanker();\nconst background = new Image();\nbackground.src = bgImg;\n\nconst BG = {\n  x1: 0,\n  x2: canvas.width,\n  y: 0,\n  width: canvas.width,\n  height: canvas.height\n}\n\nfunction createBackground() {\n  BG.x1 -= gameSpeed;\n  BG.x2 -= gameSpeed;\n\n  if (BG.x1 < -BG.width) {\n    BG.x1 = BG.x2 + BG.width; // Add new background when current moves out\n  }\n  if (BG.x2 < -BG.width) {\n    BG.x2 = BG.x1 + BG.width; // Add new background when current moves out\n  }\n\n  // Draw the background images on both sides\n  ctx.drawImage(background, BG.x1, BG.y, BG.width, BG.height);\n  ctx.drawImage(background, BG.x2, BG.y, BG.width, BG.height);\n}\n\n// Patrols\nconst patrolsArray = [];\nconst patrolImage = new Image();\npatrolImage.src = patrolImg\n\nclass Patrol {\n  constructor() {\n    // Spawn patrols off-screen to the right with some randomness\n    this.x = canvas.width + Math.random() * canvas.width * 0.5;\n    // Y position varies slightly for visual interest\n    this.y = canvas.height / 1.4 + (Math.random() * 40 - 20);\n    this.frameX = 0;\n    this.frameY = 0;\n    this.distance;\n    this.frame = 0;\n    this.spriteWidth = 52;\n    this.spriteHeight = 52;\n    this.sound = Math.random() <= 0.5 ? 'alarm1' : 'alarm2';\n    this.speed = 0.3 + Math.random() * 0.4; // Initial speed 0.3-0.7\n  }\n  update() {\n    this.age++;\n    this.x -= this.speed; // Move upward\n  }\n  setSpeed(speed) {\n    this.speed = speed\n  }\n  draw() {\n    ctx.drawImage(\n      patrolImage,\n      this.frameX * this.spriteWidth,\n      this.frameY * this.spriteHeight,\n      this.spriteWidth,\n      this.spriteHeight,\n      this.x,\n      this.y,\n      this.spriteWidth,\n      this.spriteHeight\n    );\n  }\n}\n\nfunction randomBetween(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n// Particle system for water splash effects\nclass Particle {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n    this.vx = (Math.random() - 0.5) * 2; // Small horizontal velocity\n    this.vy = (Math.random() * -2) - 0.5; // Small upward velocity\n    this.gravity = 0.15;\n    this.life = 1.0;\n    this.decay = 0.05; // Faster fade for brief splash\n    this.size = Math.random() * 1.5 + 1; // Very small particles (1-2.5px)\n    this.color = `rgba(255, 255, 255, ${this.life})`;\n  }\n\n  update() {\n    this.x += this.vx;\n    this.y += this.vy;\n    this.vy += this.gravity;\n    this.life -= this.decay;\n    const alpha = this.life * 0.6;\n    this.color = `rgba(220, 240, 255, ${alpha})`;\n  }\n\n  draw() {\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  isDead() {\n    return this.life <= 0;\n  }\n}\n\nconst particlesArray = [];\n\nfunction createSplashParticles(x, y, count = 15) {\n  for (let i = 0; i < count; i++) {\n    particlesArray.push(new Particle(x, y));\n  }\n}\n\nfunction updateParticles() {\n  for (let i = particlesArray.length - 1; i >= 0; i--) {\n    particlesArray[i].update();\n    particlesArray[i].draw();\n\n    if (particlesArray[i].isDead()) {\n      particlesArray.splice(i, 1);\n    }\n  }\n}\n\nfunction createPatrols() {\n  // Don't spawn patrols for the first 90 seconds (5400 frames) to give player time to learn\n  const minimumStartDelay = 5400; // 90 seconds at 60 FPS\n\n  // Spawn patrols very rarely: every 200-600 seconds / 3.3-10 minutes (at 60 FPS)\n  if (gameFrame > minimumStartDelay && gameFrame % randomBetween(12000, 36000) === 0) {\n    patrolsArray.push(new Patrol());\n  }\n\n  // Calculate detection risk ONLY if anchor is down\n  detectionRisk = 0;\n\n  for (let i = 0; i < patrolsArray.length; i++) {\n    // alarm1.play()\n    patrolsArray[i].update();\n    patrolsArray[i].draw();\n    if (patrolsArray[i].x > 200 && patrolsArray[i].x < 700) {\n      patrolsArray[i].setSpeed(0.5)\n\n      // Only calculate risk if anchor is down\n      if (tanker.chainLength > 0) {\n        const distance = Math.abs(patrolsArray[i].x - (tanker.x + TANKER_IMAGE_WIDTH / 2));\n        if (distance < 400) {\n          // Exponential decay: risk drops off quickly with distance\n          // At distance 0: 100%, at 200: ~14%, at 400: ~2%\n          const proximityRisk = 100 * Math.exp(-distance / 100);\n          detectionRisk = Math.max(detectionRisk, proximityRisk);\n        }\n      }\n\n      if (patrolsArray[i].x > 400 && patrolsArray[i].x < 550) {\n        if (tanker.chainLength != 0) {\n          // Accumulate warnings faster when in critical detection zone\n          warnings += 2;\n          detectionRisk = Math.max(detectionRisk, 85); // Very high risk in detection zone with anchor down\n        }\n        patrolsArray[i].setSpeed(0.3)\n      }\n    } else {\n      patrolsArray[i].setSpeed(1)\n    }\n    if (patrolsArray[i].x < (0 - 52)) {\n      score++;\n      patrolsArray.splice(i, 1);\n      i--;\n    }\n  }\n}\n\nfunction createTanker() {\n  tanker.update();\n  tanker.draw();\n\n  // Anchor position at the front right of the ship\n  const anchorX = tanker.x + (TANKER_IMAGE_WIDTH * 0.9); // Front right edge\n  const anchorY = tanker.y + TANKER_IMAGE_HEIGHT; // At ship's bottom edge\n\n  // Play warning alarm when entering critical depth (5x)\n  // Actual anchor loss is handled by Hud.update()\n  const anchorLossThreshold = hud.depth * 5;\n  if (tanker.chainLength >= anchorLossThreshold) {\n    if (previousChainLength < anchorLossThreshold) {\n      // First time crossing threshold - play alarm\n      alarm1.volume = 0.3;\n      alarm1.play().catch(() => { });\n    }\n  }\n\n  // Check if anchor was just lost (from Hud.update())\n  if (hud.anchorLost && gameFrame === hud.anchorLostTime) {\n    createSplashParticles(anchorX, anchorY, 25); // Big splash\n    splash.volume = 0.3;\n    splash.play().catch(() => { });\n    // Add detection risk penalty\n    detectionRisk = Math.min(100, detectionRisk + 20);\n  }\n\n  // Trigger small splash when anchor first deploys (0 -> 10+)\n  if (tanker.chainLength >= 10 && previousChainLength === 0) {\n    createSplashParticles(anchorX, anchorY, 10);\n    splash.volume = 0.1;\n    splash.play().catch(() => { });\n  }\n\n  // Trigger splash when anchor is raised (10+ -> 0)\n  // More particles if raising from deep deployment\n  if (tanker.chainLength === 0 && previousChainLength >= 10) {\n    const particleCount = Math.min(15, 8 + Math.floor(previousChainLength / 100));\n    createSplashParticles(anchorX, anchorY, particleCount);\n    splash.volume = Math.min(0.2, 0.1 + previousChainLength / 5000);\n    splash.play().catch(() => { });\n  }\n\n  previousChainLength = tanker.chainLength;\n}\n\n// Cable type definitions with gameplay properties\nconst CABLE_TYPES = {\n  SCRAP: {\n    name: 'Old Scrap Cable',\n    color: '#8b8b7a',\n    difficulty: 1,\n    reward: 1,\n    risk: 1,\n    rarity: 0.35, // 35% chance\n    riskIncrease: 0,\n  },\n  RESEARCH: {\n    name: 'Research Sensor Cable',\n    color: '#5a8ca8',\n    difficulty: 1,\n    reward: 2,\n    risk: 1,\n    rarity: 0.30, // 30% chance\n    riskIncrease: 5,\n  },\n  FIBER: {\n    name: 'Fiber Data Cable',\n    color: '#a8f088',\n    difficulty: 3,\n    reward: 4,\n    risk: 3,\n    rarity: 0.25, // 25% chance\n    riskIncrease: 15,\n  },\n  MILITARY: {\n    name: 'Military Surveillance Line',\n    color: '#ff6b7a',\n    difficulty: 5,\n    reward: 4,\n    risk: 5,\n    rarity: 0.06, // 6% chance\n    riskIncrease: 40,\n  },\n  HVDC: {\n    name: 'HVDC Power Cable',\n    color: '#ffa940',\n    difficulty: 5,\n    reward: 5,\n    risk: 5,\n    rarity: 0.04, // 4% chance\n    riskIncrease: 35,\n  },\n};\n\nclass Hud {\n  constructor() {\n    this.depth = Math.floor(this.generateRealisticDepth());\n    this.isAnchorDown = false;\n    this.draggedInMeters = 0;\n    this.cablesCut = 0; // Total cables severed\n    this.cablesByType = { // Track by type\n      SCRAP: 0,\n      RESEARCH: 0,\n      FIBER: 0,\n      MILITARY: 0,\n      HVDC: 0,\n    };\n    this.lastCableCut = null; // Store last cable cut info\n    this.lastCableTime = 0; // When last cable was cut\n    this.depthHistory = []; // Track past depths for graph\n    this.futureDepths = []; // Track upcoming depths for graph\n    this.maxHistoryLength = 30; // Keep 30 past readings (50% of graph)\n    this.maxFutureLength = 30; // Keep 30 future readings (50% of graph)\n    this.depthTrend = 0; // Tracks if we're in shallow basin or approaching deep depression\n    this.optimalCenterDepth = 3.0; // Center of optimal range (varies between 2.5-3.5)\n    this.optimalVariance = 0.3; // 0.3 around center\n    this.remainingAnchors = 2; // Ship has 2 anchors total\n    this.anchorLost = false; // Track if anchor was just lost\n    this.anchorLostTime = 0; // When anchor was lost\n    this.anchorLossReason = ''; // Track reason: 'cable' or 'depth'\n    this.anchorDangerStartTime = 0; // Track when anchor entered danger zone\n    this.missionSuccess = false; // Track if mission succeeded\n    this.successTime = 0; // When mission was completed\n\n    // Pre-generate initial future depths\n    this.generateFutureDepths();\n  }\n\n  // Select random cable type based on rarity\n  selectCableType() {\n    const roll = Math.random();\n    let cumulative = 0;\n\n    for (const [key, cable] of Object.entries(CABLE_TYPES)) {\n      cumulative += cable.rarity;\n      if (roll < cumulative) {\n        return { type: key, ...cable };\n      }\n    }\n    return { type: 'SCRAP', ...CABLE_TYPES.SCRAP };\n  }\n\n  // Generate future depth predictions\n  generateFutureDepths() {\n    this.futureDepths = [];\n    let lastDepth = this.depth;\n\n    for (let i = 0; i < this.maxFutureLength; i++) {\n      // Use same gradual depth generation with smoothing\n      if (Math.random() < 0.90) {\n        // Very smooth transition (90% of the time)\n        const targetDepth = this.generateRealisticDepth();\n        lastDepth = Math.floor(lastDepth * 0.92 + targetDepth * 0.08);\n      } else if (Math.random() < 0.97) {\n        // Moderate change (7% of the time)\n        const targetDepth = this.generateRealisticDepth();\n        lastDepth = Math.floor(lastDepth * 0.75 + targetDepth * 0.25);\n      } else {\n        // Sudden change (3% of the time)\n        lastDepth = Math.floor(this.generateRealisticDepth());\n      }\n      this.futureDepths.push(lastDepth);\n    }\n  }\n\n  // Update optimal depth with variance (simulates cable depth variations)\n  updateOptimalDepth() {\n    // Slowly vary the optimal depth between 2.5-3.5x\n    this.optimalCenterDepth += (Math.random() - 0.5) * 0.05; // Small random walk\n    // Clamp between 2.5 and 3.5\n    this.optimalCenterDepth = Math.max(2.5, Math.min(3.5, this.optimalCenterDepth));\n  }\n\n  // Generate realistic Baltic Sea depth with varied terrain\n  generateRealisticDepth() {\n    const rand = Math.random();\n\n    // 70% shallow basin (20-80m) - typical Baltic Sea\n    if (rand < 0.70) {\n      return randomBetween(20, 80);\n    }\n    // 20% moderate depth (80-150m) - sloping areas\n    else if (rand < 0.90) {\n      return randomBetween(80, 150);\n    }\n    // 8% deep depressions (150-300m) - glacial features\n    else if (rand < 0.98) {\n      return randomBetween(150, 300);\n    }\n    // 2% very deep (300-459m) - Landsort Deep-like trenches\n    else {\n      return randomBetween(300, 459);\n    }\n  }\n\n  update() {\n    // Less frequent depth changes: every 600 frames (10 seconds at 60 FPS)\n    if (gameFrame % 600 == 0) {\n      // Move current depth to history\n      this.depthHistory.push(this.depth);\n      if (this.depthHistory.length > this.maxHistoryLength) {\n        this.depthHistory.shift(); // Remove oldest\n      }\n\n      // Move first future depth to current\n      if (this.futureDepths.length > 0) {\n        this.depth = this.futureDepths.shift();\n      }\n\n      // Generate one new future depth to maintain the array\n      if (this.futureDepths.length > 0) {\n        const lastFuture = this.futureDepths[this.futureDepths.length - 1];\n        let newFutureDepth;\n\n        // Much more gradual depth transitions\n        if (Math.random() < 0.90) {\n          // Very smooth transition (90% of the time)\n          const targetDepth = this.generateRealisticDepth();\n          newFutureDepth = Math.floor(lastFuture * 0.92 + targetDepth * 0.08);\n        } else if (Math.random() < 0.97) {\n          // Moderate change (7% of the time)\n          const targetDepth = this.generateRealisticDepth();\n          newFutureDepth = Math.floor(lastFuture * 0.75 + targetDepth * 0.25);\n        } else {\n          // Sudden change (3% of the time)\n          newFutureDepth = Math.floor(this.generateRealisticDepth());\n        }\n\n        this.futureDepths.push(newFutureDepth);\n      }\n\n      // Update optimal cable depth variance\n      this.updateOptimalDepth();\n    }\n\n    if (gameFrame % 30 == 0) {\n      // Dynamic optimal range: center variance (e.g., 3.0 0.3 = 2.7-3.3x depth)\n      const minOptimal = this.depth * (this.optimalCenterDepth - this.optimalVariance);\n      const maxOptimal = this.depth * (this.optimalCenterDepth + this.optimalVariance);\n      const perfectOptimal = this.depth * this.optimalCenterDepth; // Best depth (e.g., 3.0x)\n\n      // Check if anchor is deployed deep enough to drag (min optimal or deeper)\n      const anchorLossThreshold = this.depth * 5; // Critical depth\n      const dangerZoneEnd = maxOptimal * 1.5;\n      const inDangerZone = tanker.chainLength > maxOptimal && tanker.chainLength <= dangerZoneEnd;\n      const inCriticalZone = tanker.chainLength >= anchorLossThreshold;\n\n      // Allow cable cutting at any depth >= minOptimal (including danger zone)\n      this.isAnchorDown = (tanker.chainLength >= minOptimal && !inCriticalZone);\n\n      if (this.isAnchorDown) {\n        this.draggedInMeters += 10;\n\n        // Cable encounter probability based on how close to perfect depth\n        const depthDiff = Math.abs(tanker.chainLength - perfectOptimal);\n        const maxDiff = perfectOptimal * this.optimalVariance;\n\n        // Probability calculation\n        let encounterChance;\n        if (tanker.chainLength <= maxOptimal) {\n          // GREEN ZONE: 1.0 at perfect depth, decreases to 0.3 at edges\n          encounterChance = 1.0 - (depthDiff / maxDiff) * 0.7;\n        } else if (inDangerZone) {\n          // DANGER ZONE (too deep): reduced efficiency (0.15 - 0.05)\n          const dangerDepth = (tanker.chainLength - maxOptimal) / (dangerZoneEnd - maxOptimal);\n          encounterChance = 0.15 - (dangerDepth * 0.10);\n        } else {\n          encounterChance = 0.05; // Very low outside zones\n        }\n\n        // Extremely rare: 0.15% base chance per check\n        if (Math.random() < encounterChance * 0.0015) {\n          // Select cable type\n          const cable = this.selectCableType();\n\n          // Difficulty check: harder cables need better depth accuracy\n          const difficultyThreshold = 1.0 - (cable.difficulty * 0.15); // Difficulty 5 = 0.25 threshold\n          const passedCheck = encounterChance >= difficultyThreshold;\n\n          if (passedCheck) {\n            this.cablesCut++;\n            this.cablesByType[cable.type]++;\n            this.lastCableCut = cable;\n            this.lastCableTime = gameFrame;\n\n            // WIN CONDITION: Successfully cutting MILITARY or HVDC cable wins the mission!\n            if (cable.type === 'MILITARY' || cable.type === 'HVDC') {\n              this.missionSuccess = true;\n              this.successTime = gameFrame;\n            }\n\n            // Increase detection risk based on cable type\n            detectionRisk = Math.min(100, detectionRisk + cable.riskIncrease);\n\n            // Risk of losing anchor when cutting cable (higher for harder cables)\n            // SCRAP: 5%, RESEARCH: 10%, FIBER: 25%, MILITARY: 40%, HVDC: 50%\n            const anchorLossChance = cable.difficulty * 0.10;\n            if (Math.random() < anchorLossChance && this.remainingAnchors > 0) {\n              this.remainingAnchors--;\n              this.anchorLost = true;\n              this.anchorLostTime = gameFrame;\n              this.anchorLossReason = 'cable'; // Lost due to cable cutting\n              tanker.chainLength = 0; // Anchor is lost, chain goes to zero\n\n              // Play alarm sound\n              alarm1.volume = 0.3;\n              alarm1.play().catch(() => { });\n\n              console.log(`Anchor lost from cable! Remaining: ${this.remainingAnchors}`);\n            }\n\n            // Play appropriate sound based on cable reward\n            if (cable.reward >= 4) {\n              // High value cables - louder, more distinct sound\n              metal3.volume = 0.25;\n              metal3.play().catch(() => { });\n              setTimeout(() => {\n                metal4.volume = 0.2;\n                metal4.play().catch(() => { });\n              }, 100);\n            } else if (cable.reward >= 2) {\n              // Medium value\n              metal3.volume = 0.15;\n              metal3.play().catch(() => { });\n            } else {\n              // Low value - subtle sound\n              metal1.volume = 0.1;\n              metal1.play().catch(() => { });\n            }\n          }\n        }\n      }\n\n      // Check if anchor is in critical danger zone (>5x depth) for too long\n      // (anchorLossThreshold already defined above in cable cutting logic)\n      if (tanker.chainLength >= this.depth * 5) {\n        // Anchor is critically deep\n        if (this.anchorDangerStartTime === 0) {\n          // Just entered danger zone\n          this.anchorDangerStartTime = gameFrame;\n        } else if (gameFrame - this.anchorDangerStartTime > 300 && this.remainingAnchors > 0) {\n          // Been in danger zone for 5 seconds (300 frames) - lose anchor!\n          this.remainingAnchors--;\n          this.anchorLost = true;\n          this.anchorLostTime = gameFrame;\n          this.anchorLossReason = 'depth'; // Lost due to being too deep\n          tanker.chainLength = 0; // Anchor is lost\n          this.anchorDangerStartTime = 0; // Reset timer\n\n          // Play alarm sound\n          alarm1.volume = 0.3;\n          alarm1.play().catch(() => { });\n\n          console.log(`Anchor lost from depth! Remaining: ${this.remainingAnchors}`);\n        }\n      } else {\n        // Not in danger zone, reset timer\n        this.anchorDangerStartTime = 0;\n      }\n    }\n  }\n}\n\nconst hud = new Hud()\n\nfunction createHud() {\n  hud.update();\n}\n\nfunction drawHUD() {\n  // Set up HUD styling\n  ctx.save();\n\n  // Cable cut notification banner (center top)\n  if (hud.lastCableCut && gameFrame - hud.lastCableTime < 1800) { // Show for 30 seconds\n    const elapsed = gameFrame - hud.lastCableTime;\n    const opacity = elapsed < 1740 ? 1.0 : (1800 - elapsed) / 60; // Fade out in last 1s\n\n    const bannerWidth = 400;\n    const bannerHeight = 70;\n    const bannerX = (canvas.width - bannerWidth) / 2;\n    const bannerY = 20;\n\n    // Background\n    ctx.globalAlpha = opacity * 0.95;\n    ctx.fillStyle = 'rgba(10, 26, 36, 0.95)';\n    ctx.fillRect(bannerX, bannerY, bannerWidth, bannerHeight);\n\n    // Border with cable color\n    ctx.strokeStyle = hud.lastCableCut.color;\n    ctx.lineWidth = 3;\n    ctx.strokeRect(bannerX, bannerY, bannerWidth, bannerHeight);\n\n    // Title\n    ctx.fillStyle = '#a8f088';\n    ctx.font = 'bold 13px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText(' CABLE DAMAGED', bannerX + bannerWidth / 2, bannerY + 20);\n\n    // Cable type name\n    ctx.fillStyle = hud.lastCableCut.color;\n    ctx.font = 'bold 16px sans-serif';\n    ctx.fillText(hud.lastCableCut.name.toUpperCase(), bannerX + bannerWidth / 2, bannerY + 42);\n\n    // Stats (Reward & Risk)\n    ctx.font = '11px sans-serif';\n    ctx.fillStyle = '#e8e8d8';\n    const rewardStars = ''.repeat(hud.lastCableCut.reward);\n    const riskLevel = hud.lastCableCut.risk >= 4 ? 'HIGH RISK' : hud.lastCableCut.risk >= 3 ? 'MEDIUM' : 'LOW RISK';\n    ctx.fillText(`Value: ${rewardStars} | ${riskLevel}`, bannerX + bannerWidth / 2, bannerY + 60);\n\n    ctx.globalAlpha = 1.0;\n    ctx.textAlign = 'left';\n  }\n\n  // Anchor lost notification banner (center top, below cable notification)\n  if (hud.anchorLost && gameFrame - hud.anchorLostTime < 1800) { // Show for 30 seconds\n    const elapsed = gameFrame - hud.anchorLostTime;\n    const opacity = elapsed < 1740 ? 1.0 : (1800 - elapsed) / 60; // Fade out in last 1s\n\n    const bannerWidth = 450;\n    const bannerHeight = 80;\n    const bannerX = (canvas.width - bannerWidth) / 2;\n    const bannerY = 100; // Below cable notification\n\n    // Background\n    ctx.globalAlpha = opacity * 0.95;\n    ctx.fillStyle = 'rgba(139, 0, 0, 0.95)'; // Dark red background\n    ctx.fillRect(bannerX, bannerY, bannerWidth, bannerHeight);\n\n    // Border\n    ctx.strokeStyle = '#ff6b7a';\n    ctx.lineWidth = 3;\n    ctx.strokeRect(bannerX, bannerY, bannerWidth, bannerHeight);\n\n    // Warning icon and title\n    ctx.fillStyle = '#ff6b7a';\n    ctx.font = 'bold 18px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText(' ANCHOR LOST! ', bannerX + bannerWidth / 2, bannerY + 25);\n\n    // Message (different based on loss reason)\n    ctx.fillStyle = '#e8e8d8';\n    ctx.font = 'bold 14px sans-serif';\n    const lossMessage = hud.anchorLossReason === 'cable'\n      ? 'Cable was too strong!'\n      : 'Anchor stayed too deep!';\n    ctx.fillText(lossMessage, bannerX + bannerWidth / 2, bannerY + 48);\n\n    // Remaining anchors\n    ctx.font = '12px sans-serif';\n    const anchorText = hud.remainingAnchors > 0\n      ? `${hud.remainingAnchors} anchor${hud.remainingAnchors === 1 ? '' : 's'} remaining`\n      : 'NO ANCHORS LEFT - MISSION FAILED!';\n    ctx.fillStyle = hud.remainingAnchors > 0 ? '#fffa80' : '#ff6b7a';\n    ctx.fillText(anchorText, bannerX + bannerWidth / 2, bannerY + 68);\n\n    ctx.globalAlpha = 1.0;\n    ctx.textAlign = 'left';\n  }\n\n  // Mission success notification banner (center, prominent)\n  if (hud.missionSuccess && gameFrame - hud.successTime < 3600) { // Show for 60 seconds\n    const elapsed = gameFrame - hud.successTime;\n    const opacity = elapsed < 3540 ? 1.0 : (3600 - elapsed) / 60; // Fade out in last 1s\n\n    const bannerWidth = 500;\n    const bannerHeight = 100;\n    const bannerX = (canvas.width - bannerWidth) / 2;\n    const bannerY = 190; // Center of screen\n\n    // Background with green glow\n    ctx.globalAlpha = opacity * 0.98;\n    ctx.fillStyle = 'rgba(42, 133, 149, 0.98)'; // Teal/cyan background\n    ctx.fillRect(bannerX, bannerY, bannerWidth, bannerHeight);\n\n    // Border\n    ctx.strokeStyle = '#a8f088';\n    ctx.lineWidth = 4;\n    ctx.strokeRect(bannerX, bannerY, bannerWidth, bannerHeight);\n\n    // Success icon and title\n    ctx.fillStyle = '#a8f088';\n    ctx.font = 'bold 24px sans-serif';\n    ctx.textAlign = 'center';\n    ctx.fillText(' MISSION SUCCESS! ', bannerX + bannerWidth / 2, bannerY + 30);\n\n    // Cable name\n    ctx.fillStyle = hud.lastCableCut.color;\n    ctx.font = 'bold 18px sans-serif';\n    ctx.fillText(hud.lastCableCut.name.toUpperCase() + ' SEVERED', bannerX + bannerWidth / 2, bannerY + 56);\n\n    // Message\n    ctx.fillStyle = '#e8e8d8';\n    ctx.font = 'bold 14px sans-serif';\n    ctx.fillText('Critical infrastructure disrupted!', bannerX + bannerWidth / 2, bannerY + 80);\n\n    ctx.globalAlpha = 1.0;\n    ctx.textAlign = 'left';\n  }\n\n  // Left side - Mission stats (simplified)\n  const leftX = 20;\n  // Use dynamic optimal range\n  const minOptimal = Math.floor(hud.depth * (hud.optimalCenterDepth - hud.optimalVariance));\n  const maxOptimal = Math.floor(hud.depth * (hud.optimalCenterDepth + hud.optimalVariance));\n  const anchorInSweetSpot = hud.isAnchorDown;\n\n  // Danger zone calculations (shared across HUD elements)\n  const anchorLossThreshold = hud.depth * 5;\n  const dangerZoneEnd = hud.depth * 7; // Red zone extends to bottom of gauge\n  const inDangerZone = tanker.chainLength > maxOptimal && tanker.chainLength <= dangerZoneEnd;\n\n  // Display remaining anchors prominently\n  ctx.fillStyle = '#e8e8d8';\n  ctx.font = 'bold 14px sans-serif';\n  const anchorDisplay = ''.repeat(hud.remainingAnchors) + ''.repeat(2 - hud.remainingAnchors);\n  ctx.fillText(`Anchors: ${anchorDisplay} | Cables: ${hud.cablesCut}`, leftX, 30);\n\n  // Debug: Log anchor count when it changes\n  if (gameFrame % 60 === 0) {\n    console.log(`Frame ${gameFrame}: Anchors remaining = ${hud.remainingAnchors}, Display = ${anchorDisplay}`);\n  }\n\n  // Anchor status with proper states\n\n  ctx.font = 'bold 15px sans-serif';\n\n  if (tanker.chainLength >= anchorLossThreshold) {\n    // State 6: Critical danger - anchor too deep, about to be lost\n    ctx.fillStyle = '#ff6b7a';\n    ctx.fillText(` ANCHOR DANGER`, leftX, 60);\n    ctx.font = '12px sans-serif';\n\n    // Show countdown timer if in danger zone\n    if (hud.anchorDangerStartTime > 0) {\n      const timeInDanger = gameFrame - hud.anchorDangerStartTime;\n      const timeRemaining = Math.max(0, 300 - timeInDanger);\n      const secondsRemaining = Math.ceil(timeRemaining / 60);\n      ctx.fillText(`ANCHOR LOST IN ${secondsRemaining}s!`, leftX, 80);\n    } else {\n      ctx.fillText(`TOO DEEP! Reel up now!`, leftX, 80);\n    }\n  } else if (inDangerZone) {\n    // State 5: Red zone - too deep, reduced cable cutting efficiency\n    ctx.fillStyle = '#ffa940';\n    ctx.fillText(` TOO DEEP`, leftX, 60);\n    ctx.font = '12px sans-serif';\n    ctx.fillText(`Low efficiency - optimal: ${minOptimal}-${maxOptimal}m`, leftX, 80);\n  } else if (tanker.chainLength === 0) {\n    // State 1: Anchor up - not deployed\n    ctx.fillStyle = '#5a8ca8';\n    ctx.fillText(`ANCHOR UP`, leftX, 60);\n    ctx.font = '12px sans-serif';\n    ctx.fillText(`Deploy to drag seabed`, leftX, 80);\n  } else if (tanker.chainLength < hud.depth) {\n    // State 2: Anchor lowered - deployed but not touching seabed\n    ctx.fillStyle = '#5a8ca8';\n    ctx.fillText(`ANCHOR LOWERED`, leftX, 60);\n    ctx.font = '12px sans-serif';\n    ctx.fillText(`Need ${hud.depth - tanker.chainLength}m more`, leftX, 80);\n  } else if (anchorInSweetSpot) {\n    // State 4: Dragging at optimal depth (green zone)\n    ctx.fillStyle = '#a8f088';\n    ctx.fillText(` DRAGGING`, leftX, 60);\n    ctx.font = '13px sans-serif';\n    ctx.fillText(`${hud.cablesCut} cables | ${(hud.draggedInMeters / 1000).toFixed(1)}km`, leftX, 80);\n  } else {\n    // State 3: Dragging - touching seabed but not in optimal range\n    ctx.fillStyle = '#fffa80';\n    ctx.fillText(` DRAGGING`, leftX, 60);\n    ctx.font = '12px sans-serif';\n    ctx.fillText(`Target: ${minOptimal}-${maxOptimal}m`, leftX, 80);\n  }\n\n  // Right side - Detection risk meter\n  const meterWidth = 180;\n  const meterHeight = 24;\n  const meterX = canvas.width - meterWidth - 20;\n  const meterY = 20;\n\n  // Detection Risk Label\n  ctx.font = 'bold 13px sans-serif';\n  ctx.fillStyle = '#e8e8d8';\n  ctx.fillText('DETECTION', meterX, meterY - 6);\n\n  // Meter background\n  ctx.fillStyle = 'rgba(21, 38, 47, 0.8)';\n  ctx.fillRect(meterX, meterY, meterWidth, meterHeight);\n\n  // Risk bar color based on level\n  let riskColor;\n  if (detectionRisk < 30) {\n    riskColor = '#a8f088'; // Green - safe\n  } else if (detectionRisk < 60) {\n    riskColor = '#fffa80'; // Yellow - caution\n  } else {\n    riskColor = '#ff6b7a'; // Red - danger\n  }\n\n  // Fill risk meter\n  const riskWidth = (detectionRisk / 100) * meterWidth;\n  ctx.fillStyle = riskColor;\n  ctx.fillRect(meterX, meterY, riskWidth, meterHeight);\n\n  // Meter border\n  ctx.strokeStyle = '#5a8ca8';\n  ctx.lineWidth = 2;\n  ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);\n\n  // Risk percentage text\n  ctx.font = 'bold 14px sans-serif';\n  ctx.fillStyle = '#0a1a24';\n  ctx.textAlign = 'center';\n  if (detectionRisk > 15) {\n    ctx.fillText(`${Math.round(detectionRisk)}%`, meterX + meterWidth / 2, meterY + 18);\n  }\n  ctx.textAlign = 'left';\n\n  // Risk status text\n  ctx.font = '11px sans-serif';\n  ctx.fillStyle = riskColor;\n  let statusText = 'CLEAR';\n  if (detectionRisk >= 60) statusText = 'DANGER';\n  else if (detectionRisk >= 30) statusText = 'CAUTION';\n  ctx.textAlign = 'center';\n  ctx.fillText(statusText, meterX + meterWidth / 2, meterY + meterHeight + 14);\n  ctx.textAlign = 'left';\n\n  // Chain depth gauge (right side, below detection meter)\n  const gaugeX = canvas.width - 70;\n  const gaugeY = 70;\n  const gaugeHeight = 140;\n  const gaugeWidth = 35;\n\n  // Fixed scale based on seabed depth: always show 0 to 7x depth\n  // This covers: seabed (1x ~14%), green zone (~38-47%), red danger zone (50-100%, lower half)\n  const gaugeMaxValue = hud.depth * 7;\n\n  // Label with current chain length\n  ctx.font = 'bold 10px sans-serif';\n  ctx.fillStyle = '#e8e8d8';\n  ctx.textAlign = 'center';\n  ctx.fillText('CHAIN', gaugeX + gaugeWidth / 2, gaugeY - 8);\n\n  // Gauge background\n  ctx.fillStyle = 'rgba(21, 38, 47, 0.8)';\n  ctx.fillRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);\n\n  // Seabed depth reference line\n  const seabedPos = (hud.depth / gaugeMaxValue) * gaugeHeight;\n  if (seabedPos <= gaugeHeight) {\n    ctx.fillStyle = 'rgba(42, 133, 149, 0.4)';\n    ctx.fillRect(gaugeX, gaugeY + seabedPos - 1, gaugeWidth, 2);\n  }\n\n  // Optimal cutting zone (green zone - dynamically calculated based on cable depth variance)\n  // Typically ~2.7x-3.3x depth (center 3.0x  0.3x variance)\n  const minOptimalPos = Math.min((minOptimal / gaugeMaxValue) * gaugeHeight, gaugeHeight);\n  const maxOptimalPos = Math.min((maxOptimal / gaugeMaxValue) * gaugeHeight, gaugeHeight);\n\n  // Orange transition zone (between green and red)\n  const orangeZoneStart = maxOptimal; // Starts right after green zone ends (~3.3x)\n  const orangeZoneEnd = hud.depth * 3.5; // Ends where red zone starts (3.5x)\n  const orangeZoneStartPos = Math.min((orangeZoneStart / gaugeMaxValue) * gaugeHeight, gaugeHeight);\n  const orangeZoneEndPos = Math.min((orangeZoneEnd / gaugeMaxValue) * gaugeHeight, gaugeHeight);\n\n  // Danger zone (red zone in lower HALF of gauge - starts at 3.5x depth)\n  // Gauge shows 0 to 7x depth, so 3.5x depth is exactly halfway\n  const dangerZoneStart = hud.depth * 3.5; // Start red zone at halfway point\n  const dangerZoneStartPos = Math.min((dangerZoneStart / gaugeMaxValue) * gaugeHeight, gaugeHeight);\n  const dangerZoneEndPos = gaugeHeight; // Red zone extends to bottom of gauge (7x depth)\n\n  // Always draw green zone (reference zone for optimal cable cutting)\n  if (maxOptimalPos > minOptimalPos) {\n    ctx.fillStyle = 'rgba(168, 240, 136, 0.25)';\n    ctx.fillRect(gaugeX, gaugeY + minOptimalPos, gaugeWidth, maxOptimalPos - minOptimalPos);\n\n    // Draw zone boundaries\n    ctx.fillStyle = '#a8f088';\n    if (minOptimalPos < gaugeHeight) {\n      ctx.fillRect(gaugeX, gaugeY + minOptimalPos - 1, gaugeWidth, 2);\n    }\n    if (maxOptimalPos < gaugeHeight) {\n      ctx.fillRect(gaugeX, gaugeY + maxOptimalPos - 1, gaugeWidth, 2);\n    }\n  }\n\n  // Draw orange transition zone (between green and red)\n  if (orangeZoneEndPos > orangeZoneStartPos && orangeZoneStartPos < gaugeHeight) {\n    const zoneHeight = orangeZoneEndPos - orangeZoneStartPos;\n    ctx.fillStyle = 'rgba(255, 169, 64, 0.25)'; // Slight orange/amber\n    ctx.fillRect(gaugeX, gaugeY + orangeZoneStartPos, gaugeWidth, zoneHeight);\n\n    // Draw orange zone boundary at the top\n    if (orangeZoneStartPos < gaugeHeight) {\n      ctx.fillStyle = '#ffa940';\n      ctx.fillRect(gaugeX, gaugeY + orangeZoneStartPos - 1, gaugeWidth, 2);\n    }\n  }\n\n  // Always draw red danger zone (reference zone for too deep)\n  if (dangerZoneEndPos > dangerZoneStartPos && dangerZoneStartPos < gaugeHeight) {\n    const zoneHeight = dangerZoneEndPos - dangerZoneStartPos;\n    ctx.fillStyle = 'rgba(255, 107, 122, 0.3)';\n    ctx.fillRect(gaugeX, gaugeY + dangerZoneStartPos, gaugeWidth, zoneHeight);\n\n    // Draw danger zone boundary at the top of red zone\n    if (dangerZoneStartPos < gaugeHeight) {\n      ctx.fillStyle = '#ff6b7a';\n      ctx.fillRect(gaugeX, gaugeY + dangerZoneStartPos - 1, gaugeWidth, 2);\n    }\n  }\n\n  // Current anchor position indicator (using inDangerZone from above)\n  const anchorPos = Math.min((tanker.chainLength / gaugeMaxValue) * gaugeHeight, gaugeHeight);\n\n  ctx.beginPath();\n  ctx.moveTo(gaugeX - 5, gaugeY + anchorPos);\n  ctx.lineTo(gaugeX + gaugeWidth + 5, gaugeY + anchorPos);\n  ctx.lineWidth = 3;\n  // Red if in danger zone, green if in sweet spot, blue otherwise\n  ctx.strokeStyle = inDangerZone ? '#ff6b7a' : (anchorInSweetSpot ? '#a8f088' : '#5a8ca8');\n  ctx.stroke();\n\n  // Gauge border\n  ctx.strokeStyle = '#5a8ca8';\n  ctx.lineWidth = 2;\n  ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);\n\n  // Current chain length below gauge\n  ctx.font = '10px sans-serif';\n  ctx.fillStyle = '#e8e8d8';\n  ctx.fillText(`${tanker.chainLength}m`, gaugeX + gaugeWidth / 2, gaugeY + gaugeHeight + 12);\n\n  // Seabed depth graph (bottom left) - 50% past, 50% future\n  if (hud.depthHistory.length > 0 || hud.futureDepths.length > 0) {\n    const graphWidth = 180;\n    const graphHeight = 45;\n    const graphX = 20;\n    const graphY = canvas.height - graphHeight - 20;\n\n    // Label\n    ctx.font = 'bold 10px sans-serif';\n    ctx.fillStyle = '#e8e8d8';\n    ctx.textAlign = 'left';\n    ctx.fillText('SEABED', graphX, graphY - 8);\n\n    // Background\n    ctx.fillStyle = 'rgba(21, 38, 47, 0.8)';\n    ctx.fillRect(graphX, graphY, graphWidth, graphHeight);\n\n    // Combine past, current, and future depths\n    const allDepths = [...hud.depthHistory, hud.depth, ...hud.futureDepths];\n    const totalPoints = allDepths.length;\n    const shipIndex = hud.depthHistory.length; // Ship is right after history\n\n    const maxDepth = Math.max(...allDepths, 470);\n    const minDepth = Math.min(...allDepths, 20);\n    const depthRange = maxDepth - minDepth || 100; // Avoid division by zero\n\n    // Draw past depths (left half, dimmer)\n    ctx.strokeStyle = 'rgba(42, 133, 149, 0.5)'; // Dimmer for past\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n\n    for (let i = 0; i < totalPoints; i++) {\n      const x = graphX + (i / (totalPoints - 1)) * graphWidth;\n      const normalizedDepth = (allDepths[i] - minDepth) / depthRange;\n      const y = graphY + graphHeight - (normalizedDepth * graphHeight);\n\n      // Change color at ship position\n      if (i === shipIndex) {\n        ctx.stroke(); // Finish past line\n        ctx.strokeStyle = '#2a8595'; // Brighter for future\n        ctx.beginPath();\n        ctx.moveTo(x, y);\n      } else if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n    ctx.stroke();\n\n    // Ship position indicator (vertical line at center)\n    const shipX = graphX + (shipIndex / (totalPoints - 1)) * graphWidth;\n    ctx.strokeStyle = 'rgba(255, 169, 64, 0.6)'; // Orange line for ship position\n    ctx.lineWidth = 2;\n    ctx.setLineDash([4, 4]); // Dashed line\n    ctx.beginPath();\n    ctx.moveTo(shipX, graphY);\n    ctx.lineTo(shipX, graphY + graphHeight);\n    ctx.stroke();\n    ctx.setLineDash([]); // Reset to solid line\n\n    // Current depth indicator (dot at ship position)\n    const currentNormalized = (hud.depth - minDepth) / depthRange;\n    const currentY = graphY + graphHeight - (currentNormalized * graphHeight);\n    ctx.fillStyle = '#ffa940'; // Orange dot\n    ctx.beginPath();\n    ctx.arc(shipX, currentY, 4, 0, Math.PI * 2);\n    ctx.fill();\n    // Outline for better visibility\n    ctx.strokeStyle = '#e8e8d8';\n    ctx.lineWidth = 1;\n    ctx.stroke();\n\n    // Border\n    ctx.strokeStyle = '#5a8ca8';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(graphX, graphY, graphWidth, graphHeight);\n\n    // Current depth text\n    ctx.font = '10px sans-serif';\n    ctx.fillStyle = '#e8e8d8';\n    ctx.textAlign = 'left';\n    ctx.fillText(`Depth: ${hud.depth}m`, graphX, graphY + graphHeight + 12);\n  }\n\n  // Cable breakdown stats (bottom right)\n  if (hud.cablesCut > 0) {\n    const statsX = canvas.width - 200;\n    const statsY = canvas.height - 130;\n    const statsWidth = 180;\n    const statsHeight = 110;\n\n    // Background\n    ctx.fillStyle = 'rgba(21, 38, 47, 0.8)';\n    ctx.fillRect(statsX, statsY, statsWidth, statsHeight);\n\n    // Border\n    ctx.strokeStyle = '#5a8ca8';\n    ctx.lineWidth = 2;\n    ctx.strokeRect(statsX, statsY, statsWidth, statsHeight);\n\n    // Title\n    ctx.font = 'bold 10px sans-serif';\n    ctx.fillStyle = '#e8e8d8';\n    ctx.textAlign = 'left';\n    ctx.fillText('CABLES DAMAGED', statsX + 10, statsY + 15);\n\n    // Cable type breakdown\n    ctx.font = '10px sans-serif';\n    let yOffset = 30;\n\n    const cableOrder = ['HVDC', 'MILITARY', 'FIBER', 'RESEARCH', 'SCRAP'];\n    cableOrder.forEach(type => {\n      const count = hud.cablesByType[type];\n      if (count > 0) {\n        const cable = CABLE_TYPES[type];\n        ctx.fillStyle = cable.color;\n        ctx.fillText(`${count} ${cable.name}`, statsX + 10, statsY + yOffset);\n        yOffset += 14;\n      }\n    });\n\n    // Total\n    ctx.font = 'bold 11px sans-serif';\n    ctx.fillStyle = '#a8f088';\n    ctx.fillText(`Total: ${hud.cablesCut}`, statsX + 10, statsY + statsHeight - 10);\n  }\n\n  ctx.textAlign = 'left';\n  ctx.restore();\n}\n\nlet backgroundSoundsStarted = false;\n\nfunction backgroundSounds() {\n  if (backgroundSoundsStarted) return; // Only start once\n\n  music.volume = 0.75;\n  music.play().catch(err => console.log('Music play failed:', err));\n\n  wind1.volume = 0.005;\n  wind1.play().catch(err => console.log('Wind play failed:', err));\n\n  waves.volume = 0.05;\n  waves.play().catch(err => console.log('Waves play failed:', err));\n\n  ship.volume = 0.01;\n  ship.play().catch(err => console.log('Ship play failed:', err));\n\n  backgroundSoundsStarted = true;\n}\n\nfunction randomCreaks() {\n  if (gameFrame % randomBetween(2000, 6000) === 0) {\n    const audioKey = `metal${randomBetween(1, 5)}`;\n    const audio = audioElements[audioKey];\n    if (audio) {\n      audio.volume = 0.1;\n      audio.play().catch(() => { });\n    }\n  }\n}\n\nlet animationId;\nfunction animate() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  if (!isPaused) {\n    backgroundSounds();\n    randomCreaks();\n    createBackground();\n    createHud();\n    createTanker();\n    createPatrols();\n    updateParticles(); // Draw particle effects\n    gameFrame++;\n  } else {\n    // Still draw static elements when paused\n    createBackground();\n    createTanker();\n    createPatrols();\n  }\n\n  drawHUD(); // Always draw HUD\n\n  // Win condition: Successfully cut a critical cable\n  if (hud.missionSuccess) {\n    // Set success message\n    const successCable = document.getElementById('success-cable');\n    if (hud.lastCableCut) {\n      successCable.textContent = `${hud.lastCableCut.name.toUpperCase()} SEVERED`;\n    }\n\n    document.getElementById('success').style.display = 'flex';\n    cancelAnimationFrame(animationId);\n    return; // Stop the animation loop\n  }\n  // Game over conditions: too many warnings OR detection risk reaches 100% OR no anchors left\n  else if (warnings > 1000 || detectionRisk >= 100 || hud.remainingAnchors <= 0) {\n    // Set failure message based on cause\n    const restartTitle = document.getElementById('restart-title');\n    const restartMessage = document.getElementById('restart-message');\n\n    if (hud.remainingAnchors <= 0) {\n      restartTitle.textContent = ' NO ANCHORS LEFT';\n      restartMessage.textContent = 'All anchors lost - Mission failed!';\n    } else if (detectionRisk >= 100) {\n      restartTitle.textContent = ' MISSION COMPROMISED';\n      restartMessage.textContent = 'You were detected by patrol vessels';\n    } else {\n      restartTitle.textContent = ' MISSION FAILED';\n      restartMessage.textContent = 'Too many warnings from patrols';\n    }\n\n    document.getElementById('restart').style.display = 'flex';\n    cancelAnimationFrame(animationId);\n    return; // Stop the animation loop\n  }\n\n  // Continue the animation loop only if game is not over\n  animationId = requestAnimationFrame(animate);\n}\n\n// Wait for DOM to be fully loaded\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initGame);\n} else {\n  initGame();\n}\n\nfunction initGame() {\n  console.log('=== Initializing game ===');\n\n  // Initialize overlays\n  const restartDiv = document.getElementById('restart');\n  const successDiv = document.getElementById('success');\n  const startDiv = document.getElementById('start');\n\n  if (restartDiv) restartDiv.style.display = 'none';\n  if (successDiv) successDiv.style.display = 'none';\n\n  // Play button\n  const playBtn = document.getElementById('play');\n  if (playBtn) {\n    console.log('Setting up play button');\n    playBtn.addEventListener('click', function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      console.log('Play button clicked - starting game');\n      if (startDiv) startDiv.style.display = 'none';\n      animate();\n    }, true);\n  } else {\n    console.error('Play button not found!');\n  }\n\n  // Retry button\n  const replayBtn = document.getElementById('replay');\n  if (replayBtn) {\n    console.log('Setting up replay button');\n    replayBtn.addEventListener('click', function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      console.log('Retry Mission button clicked - reloading');\n      window.location.reload();\n    }, true);\n  } else {\n    console.error('Replay button not found!');\n  }\n\n  // New Mission button\n  const replaySuccessBtn = document.getElementById('replay-success');\n  if (replaySuccessBtn) {\n    console.log('Setting up replay-success button');\n    replaySuccessBtn.addEventListener('click', function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      console.log('New Mission button clicked - reloading');\n      window.location.reload();\n    }, true);\n\n    // Also add mousedown as backup\n    replaySuccessBtn.addEventListener('mousedown', function (e) {\n      console.log('New Mission mousedown event');\n    }, true);\n  } else {\n    console.error('Replay-success button not found!');\n  }\n\n  console.log('Game initialization complete');\n}\n\n// Handle fullscreen canvas resizing\ndocument.addEventListener('fullscreenchange', function () {\n  if (document.fullscreenElement) {\n    // Entering fullscreen - scale canvas while maintaining aspect ratio\n    const aspectRatio = DEFAULT_WIDTH / DEFAULT_HEIGHT; // 1.6\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n    const viewportAspectRatio = viewportWidth / viewportHeight;\n\n    let newWidth, newHeight;\n\n    if (viewportAspectRatio > aspectRatio) {\n      // Viewport is wider - scale by height\n      newHeight = viewportHeight;\n      newWidth = newHeight * aspectRatio;\n    } else {\n      // Viewport is taller - scale by width\n      newWidth = viewportWidth;\n      newHeight = newWidth / aspectRatio;\n    }\n\n    canvas.style.width = newWidth + 'px';\n    canvas.style.height = newHeight + 'px';\n    // Keep internal resolution the same\n    canvas.width = DEFAULT_WIDTH;\n    canvas.height = DEFAULT_HEIGHT;\n  } else {\n    // Exiting fullscreen - reset styles\n    canvas.style.width = '800px';\n    canvas.style.height = '500px';\n    canvas.width = DEFAULT_WIDTH;\n    canvas.height = DEFAULT_HEIGHT;\n  }\n  // Reset font size for text rendering\n  ctx.font = '24px sans-serif';\n});\n","module.exports = new __parcel__URL__(\"bg.51ef01c9.png\").toString();","module.exports = new __parcel__URL__(\"patrol.9736c357.png\").toString();","module.exports = new __parcel__URL__(\"tanker-sprite-2.95dcef17.png\").toString();"],"names":["$4ee2b06a9c1953f0$var$animationId","$parcel$interopDefault","a","__esModule","default","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","Object","defineProperty","get","$18c11f3350a906ea$export$6503ec6e8aabbaf","set","v","enumerable","configurable","$18c11f3350a906ea$var$mapping","Map","baseUrl","manifest","i","length","path","URL","url","toString","JSON","parse","$ec1cf3883ace6448$exports","$2ae5a384eaded8e6$exports","$6f487f3626976b0d$exports","$4ee2b06a9c1953f0$var$canvas","document","getElementById","$4ee2b06a9c1953f0$var$ctx","getContext","width","height","$4ee2b06a9c1953f0$var$score","$4ee2b06a9c1953f0$var$gameFrame","$4ee2b06a9c1953f0$var$warnings","$4ee2b06a9c1953f0$var$previousChainLength","$4ee2b06a9c1953f0$var$isPaused","$4ee2b06a9c1953f0$var$detectionRisk","font","window","gameState","isPaused","value","allAudio","querySelectorAll","forEach","audio","paused","pause","$4ee2b06a9c1953f0$var$music","play","catch","$4ee2b06a9c1953f0$var$wind1","$4ee2b06a9c1953f0$var$waves","$4ee2b06a9c1953f0$var$ship","$4ee2b06a9c1953f0$var$audioElements","metal1","metal2","metal3","metal4","metal5","$4ee2b06a9c1953f0$var$winch1","$4ee2b06a9c1953f0$var$winch5","$4ee2b06a9c1953f0$var$winch8","$4ee2b06a9c1953f0$var$scrape7","$4ee2b06a9c1953f0$var$alarm1","$4ee2b06a9c1953f0$var$splash","$4ee2b06a9c1953f0$var$metal1","$4ee2b06a9c1953f0$var$metal2","$4ee2b06a9c1953f0$var$metal3","$4ee2b06a9c1953f0$var$metal4","$4ee2b06a9c1953f0$var$metal5","$4ee2b06a9c1953f0$var$targetPosition","x","$4ee2b06a9c1953f0$var$TANKER_IMAGE_WIDTH","y","addEventListener","e","preventDefault","key","$4ee2b06a9c1953f0$var$tanker","chainLength","Math","max","volume","$4ee2b06a9c1953f0$var$hud","remainingAnchors","min","chainLengthMax","$4ee2b06a9c1953f0$var$tankerImage","Image","src","constructor","frameX","frameY","frame","spriteWidth","spriteHeight","update","dx","dy","speedMultiplier","lastCableCut","lastCableTime","cableDifficulty","difficulty","depth","dragRatio","dragAmount","deployRatio","effectiveSpeed","minOptimal","maxOptimal","inSweetSpot","random","metalSounds","randomMetal","floor","isAnchorDown","draw","drawImage","$4ee2b06a9c1953f0$var$background","$4ee2b06a9c1953f0$var$BG","x1","x2","$4ee2b06a9c1953f0$var$createBackground","$4ee2b06a9c1953f0$var$patrolsArray","$4ee2b06a9c1953f0$var$patrolImage","$4ee2b06a9c1953f0$var$Patrol","distance","sound","speed","age","setSpeed","$4ee2b06a9c1953f0$var$randomBetween","$4ee2b06a9c1953f0$var$Particle","vx","vy","gravity","life","decay","size","color","alpha","fillStyle","beginPath","arc","PI","fill","isDead","$4ee2b06a9c1953f0$var$particlesArray","$4ee2b06a9c1953f0$var$createSplashParticles","count","push","$4ee2b06a9c1953f0$var$createPatrols","abs","exp","splice","$4ee2b06a9c1953f0$var$createTanker","anchorX","anchorY","anchorLossThreshold","anchorLost","anchorLostTime","$4ee2b06a9c1953f0$var$CABLE_TYPES","SCRAP","name","reward","risk","rarity","riskIncrease","RESEARCH","FIBER","MILITARY","HVDC","generateRealisticDepth","draggedInMeters","cablesCut","cablesByType","depthHistory","futureDepths","maxHistoryLength","maxFutureLength","depthTrend","optimalCenterDepth","optimalVariance","anchorLossReason","anchorDangerStartTime","missionSuccess","successTime","generateFutureDepths","selectCableType","roll","cumulative","cable","entries","type","lastDepth","targetDepth","updateOptimalDepth","rand","shift","newFutureDepth","lastFuture","perfectOptimal","dangerZoneEnd","inDangerZone","inCriticalZone","encounterChance","depthDiff","maxDiff","dangerDepth","console","log","setTimeout","$4ee2b06a9c1953f0$var$backgroundSoundsStarted","$4ee2b06a9c1953f0$var$initGame","restartDiv","successDiv","startDiv","style","display","playBtn","stopPropagation","$4ee2b06a9c1953f0$var$animate","clearRect","$4ee2b06a9c1953f0$var$randomCreaks","$4ee2b06a9c1953f0$var$updateParticles","$4ee2b06a9c1953f0$var$drawHUD","riskColor","save","elapsed","bannerX","globalAlpha","opacity","fillRect","strokeStyle","lineWidth","strokeRect","textAlign","fillText","bannerWidth","bannerY","toUpperCase","rewardStars","repeat","riskLevel","lossMessage","anchorText","anchorInSweetSpot","anchorDisplay","secondsRemaining","ceil","timeRemaining","toFixed","meterX","meterY","riskWidth","round","meterWidth","statusText","gaugeX","gaugeMaxValue","gaugeWidth","gaugeY","seabedPos","minOptimalPos","maxOptimalPos","orangeZoneEnd","orangeZoneStartPos","orangeZoneStart","orangeZoneEndPos","dangerZoneStartPos","dangerZoneStart","dangerZoneEndPos","anchorPos","moveTo","lineTo","stroke","graphY","allDepths","totalPoints","shipIndex","maxDepth","minDepth","depthRange","graphX","normalizedDepth","shipX","setLineDash","currentY","currentNormalized","statsX","statsY","yOffset","cableOrder","restore","successCable","textContent","cancelAnimationFrame","restartTitle","restartMessage","requestAnimationFrame","error","replayBtn","location","reload","replaySuccessBtn","readyState","fullscreenElement","newWidth","newHeight","viewportWidth","innerWidth","viewportHeight","innerHeight","viewportAspectRatio","$4ee2b06a9c1953f0$var$DEFAULT_WIDTH"],"version":3,"file":"index.461ec126.js.map"}